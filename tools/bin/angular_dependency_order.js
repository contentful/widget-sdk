#!/usr/bin/env node

const path = require('path');
const fs = require('fs');
const babel = require('babel-core');
const trailduck = require('trailduck').default;
const { createBabelOptions } = require('../app-babel-options');
const _ = require('lodash');

/*
  This script determines the dependency graph for the application.

  These cases are handled:
  1. Plain imports, e.g. ImportDeclaration
  2. getModule statements
  3. Angular DI dependencies, and those via `$injector.get`
  4. Calls using `require`
 */

const sourceDir = path.resolve(__dirname, '..', '..', 'src', 'javascripts');

// Read through the source directory, and determine the dependencies for each .js file
const dependencies = recursiveRead(sourceDir);

// Get all files that have Angular registrations and generate
// a dependency chain that Trailduck understands
const ngDependencyChain = _.chain(dependencies)
  .pickBy(dependencyInfo => dependencyInfo.registrations.length > 0)
  .mapValues(dependencyInfo => ({
    children: determineChildren(dependencyInfo)
  }))
  .value();

const dfs = new trailduck(ngDependencyChain);
const list = dfs.ordered.map(node => node.name);

console.log(
  '// This list is automatically generated by tools/bin/angular_dependency_order.js. Do not modify.'
);
console.log(list.map(item => requireString(item, 'ngRequire')).join('\n'));

/*
  Recursively read through directory `p`, and determine
  dependencies for each .js file.

  Returns object with filename as key and dependency info as value.
 */
function recursiveRead(p) {
  const dependencies = {};

  fs.readdirSync(p).forEach(name => {
    const resolved = path.resolve(p, name);
    const isJsFile = resolved.endsWith('.js');
    const isSpecFile = isJsFile && resolved.endsWith('.spec.js');

    // Ignore .spec.js files
    if (isSpecFile) {
      return;
    }

    const stats = fs.statSync(resolved);

    if (stats.isFile() && isJsFile) {
      const [filename, depInfo] = determineDependencies(resolved);

      dependencies[filename] = depInfo;
    } else if (stats.isDirectory()) {
      const dirDependencies = recursiveRead(resolved);

      Object.assign(dependencies, dirDependencies);
    }
  });

  return dependencies;
}

/*
  Parses given filename `p` through Babel and determines the following
  information:

  1. The directly imported files
  2. The registrations e.g. registerFactory
  3. The dependencies registered via Angular DI and $injector.get
  4. The indirect dependencies via getModule
  5. The dependencies via require
 */
function determineDependencies(p) {
  const raw = fs.readFileSync(p).toString();
  const babelOptions = createBabelOptions({
    angularModules: false
  });

  let ast;

  try {
    ast = babel.transform(raw, babelOptions).ast;
  } catch (e) {
    console.log(`Could not parse ${p}`);
    console.log(e);

    return;
  }

  const regUtils = [
    'registerController',
    'registerDirective',
    'registerFilter',
    'registerFactory',
    'registerService',
    'registerConstant',
    'registerProvider',
    'registerValue'
  ];

  const registrations = [];
  const imports = [];
  const ng = [];

  babel.traverse(ast, {
    enter: ({ node }) => {
      if (node.type === 'ImportDeclaration') {
        const value = node.source.value;

        imports.push(normalizeImport(p, value));
      }

      if (node.type === 'CallExpression') {
        const { callee, arguments: args } = node;

        // Ignore all non-string calls to these functions.
        //
        // E.g. allow `require('myModule.es6')` and reject `require(module)`
        if (!args[0] || args[0].type !== 'StringLiteral') {
          return;
        }

        // Angular module registration
        if (regUtils.includes(callee.name)) {
          registrations.push(args[0].value);

          if (args[1].type !== 'ArrayExpression') {
            return;
          }

          // DI registrations may be either an ng dependency or file
          args[1].elements.slice(0, -1).forEach(({ value: depName }) => {
            const [dependencyType, realDepName] = realDependencyWithType(depName);

            if (dependencyType === 'import') {
              imports.push(realDepName);
            } else if (dependencyType === 'ng') {
              ng.push(realDepName);
            }
          });
        }

        // getModule, assume only Angular
        if (callee.name === 'getModule') {
          ng.push(args[0].value);
        }

        // require, assume only file
        if (callee.name === 'require') {
          const value = args[0].value;

          imports.push(normalizeImport(p, value));
        }

        // $injector.get, may be ng dependency or file
        if (
          _.get(callee, 'object.name') === '$injector' &&
          _.get(callee, 'property.name') === 'get'
        ) {
          const injectedNode = args[0];
          const depName = injectedNode.value;
          const [dependencyType, realDepName] = realDependencyWithType(depName);

          if (dependencyType === 'import') {
            imports.push(realDepName);
          } else if (dependencyType === 'ng') {
            ng.push(realDepName);
          }
        }
      }
    }
  });

  const filename = p.split('src/javascripts/')[1];

  return [
    filename,
    {
      imports,
      ng: _.uniq(ng),
      registrations
    }
  ];
}

/*
  Given `depName`, return the type of the dependency with the "real" dependency
  name.

  There may be cases when something is imported without index.es6 appended, so
  there are two cases for `import` types. You cannot trust these implicitly, they
  may be fake news.

  The reality determining logic will not be necessary once all imports are explicit,
  e.g. all imported files use `index.es6` if needed.
 */
function realDependencyWithType(depName) {
  // For now, $injector.get could have either a filename or an Angular dep
  //
  // Determine if it is a file and if so, put it in imports. Otherwise, put in di

  // Since it cannot be relative, we can assume it comes from sourceDir
  const testPath = path.resolve(sourceDir, `${depName}.js`);
  const testPathWithIndex = path.resolve(sourceDir, `${depName}/index.es6.js`);

  if (fs.existsSync(testPath)) {
    return ['import', `${depName}.js`];
  } else if (fs.existsSync(testPathWithIndex)) {
    return ['import', `${depName}/index.es6.js`];
  } else {
    return ['ng', depName];
  }
}

/*
  Determines filename for given `ngDep`.
 */
function findFilenameForNgDep(ngDep) {
  // Special case: $filter
  if (ngDep === '$filter') {
    return 'filters.es6.js';
  }

  const found = Object.entries(dependencies).find(([, dep]) => dep.registrations.includes(ngDep));

  if (!found) {
    return null;
  }

  return found[0];
}

/*
  Runs _.uniq on a reversed array.
 */
function uniqReverse(arr) {
  return _.chain(arr)
    .reverse()
    .uniq()
    .reverse()
    .value();
}

/*
  Gets all indirect imports, i.e. getModule uses in files
  directly imported.
 */
function getIndirectNgDeps(imp) {
  const dep = dependencies[`${imp}.js`];

  if (!dep) {
    return [];
  }

  const ngDeps = dep.ng.map(module => module);
  const importedDeps = dep.imports.map(getIndirectNgDeps);

  return _.flatten(ngDeps.concat(importedDeps));
}

/*
  Determines the children for given dependencies.
 */
function determineChildren(info) {
  // Get all DI and getModule deps (considered "direct" dependencies)
  const ngDeps = info.ng.map(module => module);
  // Get all indirect deps, via imported files
  const indirectDeps = _.flatten(info.imports.map(imp => getIndirectNgDeps(imp)));

  return uniqReverse(
    indirectDeps.concat(ngDeps).reduce((memo, name) => {
      const filenameForDep = findFilenameForNgDep(name);

      if (filenameForDep) {
        memo.push(filenameForDep);
      }

      return memo;
    }, [])
  );
}

/*
  Normalizes import to path within src/javascripts, if relative.
 */
function normalizeImport(p, importName) {
  let normalized = path.resolve(sourceDir, importName);

  if (importName.startsWith('.')) {
    normalized = path.resolve(path.dirname(p), importName);
  }

  return normalized.split('src/javascripts/')[1];
}

/*
  Generate string used in AngularInit.js.

  By default returns a string like:

  `require('myDepName.es6')`
 */
function requireString(filename, requireFunc = 'require') {
  const dependencyName = filename.split('.js')[0];
  return `${requireFunc}('${dependencyName}');`;
}
