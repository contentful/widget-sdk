import _ from 'lodash';
import ldClient from 'ldclient-js';
import {
  getOrgRole,
  isUserOrgCreator,
  getUserAgeInDays,
  ownsAtleastOneOrg,
  hasAnOrgWithSpaces,
  isAutomationTestUser,
  getUserSpaceRoles,
  getUserCreationDateUnixTimestamp
} from 'data/User/index.es6';
import * as config from 'Config.es6';
import * as logger from 'services/logger.es6';
import { isFlagOverridden, getFlagOverride } from 'debug/EnforceFlags.es6';
import getOrgStatus from 'data/OrganizationStatus.es6';
import {
  getOrganization,
  getSpace,
  getUser,
  getSpacesByOrganization
} from 'services/TokenStore.es6';

let flagsCache = {};

/*
  During testing, allows for clearing the flags cache.

  This is necessary since we cache the flags from LD, but do not create a single instance
  of this service and then expose it somewhere in the application.
 */
export function _clearFlagsCache() {
  if (process.env.NODE_ENV === 'test') {
    flagsCache = {};
  } else {
    throw new Error('Clearing LaunchDarkly client cache is only available in testing.');
  }
}

/**
 * @description
 * Builds a LaunchDarkly user with custom data to help us arget users.
 *
 * Custom attributes that can be used in targeting users:
 * - currentOrgId : current org in the app the user is in the context of
 * - currentOrgSubscriptionStatus : one of free, paid, free_paid, trial
 * - currentOrgPlanIsEnterprise : true if the current org is on an enterprise plan
 * - currentOrgHasSpace : true if the current org has a space
 * - currentOrgPricingVersion : the current organization pricing version, currently either `pricing_version_1` or `pricing_version_2`

 * - currentUserOrgRole : user's role in current org
 * - currentUserHasAtleastOneSpace : true if the user has atleast one space in all the orgs he/she is a member of
 * - currentUserOwnsAtleastOneOrg : true if the user is the owner of atleast one org
 * - currentUserAge : days since user signed up
 * - currentUserCreationDate: current user creation date as a unix timestamp (generated by moment and not the same as Date.now())
 * - currentUserIsCurrentOrgCreator : true if the current org was created by the current user
 * - currentUserSignInCount : count of the number of times the current user has signed in
 * - isNonPayingUser : true if non of the orgs the user belongs to is paying us
 * - currentSpaceId : id of the space the user is in
 * - currentUserSpaceRole : list of lower case roles that user has for current space
 * - isAutomationTestUser : true if the current user was created by the automation suite
 *
 * @param {Object} user
 * @param {Object} org
 * @param {Object} space
 *
 * @returns {Object} customData
 */

async function ldUser(user, org, space) {
  let customData = {
    currentUserSignInCount: user.signInCount,

    // by default, if there is no current space, we pass empty array
    currentUserSpaceRole: [],

    isAutomationTestUser: isAutomationTestUser(user),
    currentUserOwnsAtleastOneOrg: ownsAtleastOneOrg(user),
    currentUserAge: getUserAgeInDays(user),
    currentUserCreationDate: getUserCreationDateUnixTimestamp(user)
  };

  if (org) {
    const {
      sys: { id: orgId }
    } = org;

    const orgStatus = await getOrgStatus(org);
    const spacesByOrg = getSpacesByOrganization();

    customData = _.assign({}, customData, {
      currentOrgId: orgId,
      currentOrgSubscriptionStatus: _.get(org, 'subscription.status', null),
      currentOrgPricingVersion: org.pricingVersion,
      currentOrgPlanIsEnterprise: _.get(orgStatus, ['isEnterprise'], false),
      currentOrgHasSpace: Boolean(_.get(spacesByOrg, [orgId, 'length'], 0)),

      currentUserOrgRole: getOrgRole(user, orgId),
      currentUserHasAtleastOneSpace: hasAnOrgWithSpaces(spacesByOrg),
      currentUserIsCurrentOrgCreator: isUserOrgCreator(user, org),

      isNonPayingUser: !_.get(orgStatus, ['isPaid'], false)
    });
  }

  if (space) {
    const roles = getUserSpaceRoles(space);
    customData = _.assign({}, customData, {
      currentSpaceId: space.sys.id,
      currentUserSpaceRole: roles
    });
  }

  return {
    key: user.sys.id,
    custom: _.omitBy(customData, _.isNull)
  };
}

/**
 * @usage[js]
 * import { getVariation } from 'utils/LaunchDarkly'
 *
 * const variation = await getVariation('my-test-or-feature-flag', { orgId: '1234' })
 *
 * @description
 * This function returns a promise that resolves to the variation for the
 * provided test or feature flag name for the given orgId or spaceId. If the flag name
 * is overridden using `ui_enable_flags`, then a promise that resolves to the
 * overridden value is returned.
 *
 * NOTE: a flag's value can be overridden using ui_(enable|disable)_flags query param.
 *
 * Guarantees provided:
 * 1. If flag is overridden
 *   1. The promise returned will resolve to the overridden value of the flag
 *
 * 2. If the flag is NOT overridden
 *   1. The promise will settle only when LD is ready for the given context
 *      where context is a combination of current user, and given org and space IDs.
 *   2. The promise will resolve with the variation for the provided flag name
 *      if it receives a variation from it from LD.
 *   3. The promise will resolve with `undefined` if LD does not find a flag
 *      with the provided flag name. An error will be logged to bugsnag.
 *
 *      NOTE: this can also happen in rare cases even if a flag does exist (e.g. LD
 *      service is down) and you should keep it in mind if your default value is not
 *      falsy.
 *
 * @param {String} flagName
 * @returns {Promise<Variation>}
 */
export async function getVariation(flagName, { orgId, spaceId } = {}) {
  /**
   * if the flag is overridden, don't wait to
   * connect to LD before returning the overridden
   * variation.
   */
  if (isFlagOverridden(flagName)) {
    return Promise.resolve(getFlagOverride(flagName));
  }

  // The flagsCache key will look like this:
  //
  // Only org ID:
  // `org_abcd1234:`
  //
  // Only space ID:
  // `:space_abcd1234`
  //
  // Org and space ID:
  // `org_abcd1234:space_abcd1234`
  //
  // No ID:
  // `:`
  const key = `${orgId ? orgId : ''}:${spaceId ? spaceId : ''}`;

  const flags = _.get(flagsCache, key, null);

  if (!flags) {
    const user = getUser();

    let org;
    let space;

    // Attempt to get the org and space, if given an ID.
    //
    // If the ID results in an unknown org or space, log the
    // error to Bugsnag and return undefined.
    try {
      org = orgId ? await getOrganization(orgId) : null;
    } catch (e) {
      logger.logError(`Invalid org ID ${orgId} given to LD`);

      return undefined;
    }

    try {
      space = spaceId ? await getSpace(spaceId) : null;
    } catch (e) {
      logger.logError(`Invalid space ID ${spaceId} given to LD`);

      return undefined;
    }

    // Get the user data that will be used for LD client variation data
    const clientUser = await ldUser(user, org, space);
    const client = ldClient.initialize(config.launchDarkly.envId, clientUser);
    const initialized = await isInitialized(client);

    // If the client is not initialized, log error and return undefined
    if (!initialized) {
      logger.logError(`LD not initialized when calling for ${flagName}`);
      return undefined;
    }

    // Get and save the flags to the cache
    const flags = client.allFlags();

    _.set(flagsCache, key, flags);
  }

  const variation = _.get(flagsCache, [key, flagName], undefined);

  // LD could not find a flag with given name, log error and return undefined
  if (variation === undefined) {
    logger.logError(`Invalid flag ${flagName}`);
    return undefined;
  }

  // Should never happen, but if the variation data could not be parsed
  // log the error and return undefined
  try {
    return JSON.parse(variation);
  } catch (e) {
    logger.logError(`Invalid JSON for ${flagName}: ${variation}`);

    return undefined;
  }
}

/*
  Waits for the LD client to initialize.

  Waits 250ms twice. If the client does not
  initialize within the whole 500ms, returns `false`.

  If the client initializes, returns `true`.
 */
async function isInitialized(client, n = 0) {
  let bound;

  const ready = await Promise.race([
    new Promise(resolve => {
      bound = resolve.bind(this, true);

      client.on('ready', bound);
    }),
    new Promise(resolve => setTimeout(resolve.bind(this, false), 250))
  ]);

  client.off('ready', bound);

  if (!ready && n < 1) {
    return isInitialized(client, n + 1);
  } else if (!ready) {
    return false;
  }

  return true;
}
