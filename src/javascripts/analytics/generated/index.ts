/**
 * This client was automatically generated by Segment Typewriter. ** Do Not Edit **
 */

/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 *
 * You can install it with: `npm install --save-dev ajv`.
 */
import Ajv from 'ajv';
import * as Segment from './segment';

export interface Payload {
  has_inaccessible_tasks?: boolean;
  num_pending_tasks?: number;
  num_visible_pending_tasks?: number;
}
export interface Data {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload;
  scope?: string;
  space_key?: string;
}
export interface AccountDropdownPendingTasksFetched {
  data?: Data;
}
export interface Payload1 {
  definition_id?: string;
}
export interface Data1 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload1;
  scope?: string;
}
export interface AppManagementCreated {
  data?: Data1;
}
export interface Payload2 {
  definition_id?: string;
}
export interface Data2 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload2;
  scope?: string;
}
export interface AppManagementUpdated {
  data?: Data2;
}
export interface Data3 {
  app_event_name?: string;
  contentful_app_id?: string;
  contentful_event_id?: string;
  environment_key?: string;
  organization_key?: string;
  space_key?: string;
}
export interface AppsLifecycleEvent {
  data?: Data3;
}
export interface AssetCreated {
  asset_id?: string;
  environment?: string;
  space_key?: string;
  version?: string;
}
export interface Data4 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Record<string, any>;
  scope?: string;
  space_key?: string;
}
export interface AssetListAddAssetMultiple {
  data?: Data4;
}
export interface Data5 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Record<string, any>;
  scope?: string;
  space_key?: string;
}
export interface AssetListAddAssetSingle {
  data?: Data5;
}
export interface AssetPublished {
  asset_id?: string;
  environment?: string;
  space_key?: string;
  version?: string;
}
export interface Data6 {
  action?: string;
  environment_key?: string;
  num_edited_entries?: number;
  num_published_entries?: number;
  organization_key?: string;
  parent_entry_id?: string;
  ref_count?: number;
  space_key?: string;
}
export interface BulkEditorClose {
  data?: Data6;
}
export interface Data7 {
  action?: string;
  entry_id?: string;
  environment_key?: string;
  organization_key?: string;
  parent_entry_id?: string;
  ref_count?: number;
  space_key?: string;
}
export interface BulkEditorEditInEntryEditor {
  data?: Data7;
}
export interface Data8 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  parent_entry_id?: string;
  ref_count?: number;
  space_key?: string;
}
export interface BulkEditorOpen {
  data?: Data8;
}
export interface Data9 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  parent_entry_id?: string;
  ref_count?: number;
  space_key?: string;
}
export interface BulkEditorOpenSlideIn {
  data?: Data9;
}
export interface EditorInterfaceFieldUpdated {
  content_type_id?: string;
  environment_key?: string;
  field_id?: string;
  field_settings?: Record<string, any>;
  field_type?: string;
  organization_key?: string;
  space_key?: string;
  widget_id?: string;
}
export interface EditorLoaded {
  /**
   * `init` is triggered every time a slide is loaded. `entity_loaded` is triggered when the editor's main entity is loaded. `sharejs_connected` is triggered when a connection with ShareJS has been established while in case ShareJS is not used for the editor, the more generic `doc_connected` is triggered. `links_rendered` is triggered when all the links (references, media, and rich text embeds / entry hyperlinks) in a slide have been fetched and rendered. `fully_interactive` is trigger when both the links have rendered and the entry has become editable (i.e. ShareJS has connected).
   */
  action?: string;
  environment_key?: string;
  /**
   * The total number of links (reference links, media field assets, rich text embedded block and inline entries, rich text embedded block assets, and rich text hyperlinked entries) in the entry on initial load
   */
  link_count?: number;
  /**
   * The overall number of reference and media field instances in an individual entry (1 locale field = 1 instance)
   */
  link_field_editor_instance_count?: number;
  /**
   * Number of milliseconds since the initial load of the entry
   */
  load_ms?: number;
  organization_key?: string;
  /**
   * The overall number of rich text editor instances in an individual entry (1 locale field editor = 1 instance)
   */
  rich_text_editor_instance_count?: number;
  /**
   * Level of the entry editor within the slides (zero-indexed, -1 if the slide was closed at the time the event is triggered)
   */
  slide_level?: number;
  /**
   * ID uniquely identifying the slide instance - does NOT uniquely identify the entry
   */
  slide_uuid?: string;
  /**
   * ID uniquely identifying the overall session and therefore all slides loaded around the same time within the same browser tab
   */
  slides_controller_uuid?: string;
  space_key?: string;
  /**
   * The total number of slides open when the entry is initially loaded, default = 0 if there are no slides
   */
  total_slide_count?: number;
}
export interface Payload3 {
  tab_name?: string;
}
export interface Data10 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload3;
  scope?: string;
  space_key?: string;
}
export interface EditorWorkbenchTabOpen {
  data?: Data10;
}
export interface ElementClick {
  contexts?: string;
  element_id?: string;
  environment_key?: string;
  from_state?: string;
  group_id?: string;
  organization_key?: string;
  space_key?: string;
}
export interface EntryPublish {
  action?: string;
  content_type_id?: string;
  contexts?: string;
  entry_ct_entry_reference_fields_count?: number;
  entry_id?: string;
  event_origin?: string;
  has_legacy_extensions?: boolean;
  is_default?: boolean;
  organization_key?: string;
  space_key?: string;
  version?: number;
}
export interface Payload4 {
  circular_references_count?: number;
  entity_id?: string;
  references_depth?: number;
  references_per_level?: number[];
}
export interface Data11 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload4;
  scope?: string;
  space_key?: string;
}
export interface EntryReferencesDialogOpen {
  data?: Data11;
}
export interface Payload5 {
  entity_id?: string;
  references_count?: number;
}
export interface Data12 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload5;
  scope?: string;
  space_key?: string;
}
export interface EntryReferencesPublish {
  data?: Data12;
}
export interface Payload6 {
  entity_id?: string;
  references_count?: number;
}
export interface Data13 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload6;
  scope?: string;
  space_key?: string;
}
export interface EntryReferencesValidate {
  data?: Data13;
}
export interface ExperimentStarted {
  environment_key?: string;
  /**
   * The experiment name the current user is part of
   */
  experiment_id: string;
  /**
   * The experiment variation the current user is assigned to
   */
  experiment_variation: string;
  /**
   * Current organization key
   */
  organization_key?: string;
  /**
   * Current space key
   */
  space_key?: string;
}
export interface GlobalAppLoaded {
  action?: string;
  contexts?: string;
  organization_key?: string;
  space_key?: string;
}
export interface Data14 {
  action?: string;
  environment_key?: string;
  name?: string;
  organization_key?: string;
  purpose?: string;
  space_key?: string;
}
export interface GlobalDialog {
  data?: Data14;
  schema?: string;
}
export interface GlobalSpaceChanged {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Record<string, any>;
  scope?: string;
  space_key?: string;
}
export interface GlobalSpaceLeft {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Record<string, any>;
  scope?: string;
}
export interface FromStateParams {
  accepted_permissions?: any | null;
  add_to_context?: boolean;
  api_key_id?: string;
  app_id?: any | null;
  asset_id?: string;
  content_type_id?: string;
  definition_id?: string;
  entry_id?: string;
  environment_key?: string;
  ignore_leave_confirmation?: boolean;
  invitation_id?: string;
  jump_to_role?: string;
  locale_id?: string;
  org_id?: any | null;
  org_owner_or_admin?: any | null;
  path_suffix?: string;
  referrer?: any | null;
  space_key?: string;
  tab?: string;
  template_id?: any | null;
  user_id?: string;
  webhook_id?: string;
}
export interface ToStateParams {
  accepted_permissions?: any | null;
  add_to_context?: boolean;
  api_key_id?: string;
  app_id?: any | null;
  asset_id?: string;
  content_type_id?: string;
  definition_id?: string;
  entry_id?: string;
  environment_key?: string;
  ignore_leave_confirmation?: boolean;
  jump_to_role?: string;
  locale_id?: string;
  org_id?: string;
  org_owner_or_admin?: any | null;
  path_suffix?: string;
  referrer?: any | null;
  space_key?: string;
  tab?: string;
  template_id?: any | null;
  user_id?: string;
  webhook_id?: string;
}
export interface Data15 {
  from_state?: string;
  from_state_params?: FromStateParams;
  organization_key?: string;
  space_key?: string;
  to_state?: string;
  to_state_params?: ToStateParams;
}
export interface GlobalStateChanged {
  data?: Data15;
}
export interface Payload7 {
  dialog_action?: string;
  dialog_session_id?: string;
  entity_id?: string;
  entity_type?: string;
  incoming_links_count?: number;
}
export interface Data16 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload7;
  scope?: string;
  space_key?: string;
}
export interface IncomingLinksDialogConfirm {
  data?: Data16;
}
export interface Payload8 {
  dialog_action?: string;
  dialog_session_id?: string;
  entity_id?: string;
  entity_type?: string;
  incoming_links_count?: number;
}
export interface Data17 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload8;
  scope?: string;
  space_key?: string;
}
export interface IncomingLinksDialogOpen {
  data?: Data17;
}
export interface Payload9 {
  entity_id?: string;
  entity_type?: string;
  incoming_link_ids?: string[];
  incoming_links_count?: number;
}
export interface Data18 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload9;
  scope?: string;
  space_key?: string;
}
export interface IncomingLinksQuery {
  data?: Data18;
}
export interface Payload10 {
  state_name?: string;
  value?: number;
}
export interface Data19 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload10;
  scope?: string;
  space_key?: string;
}
export interface PerfDomContentLoaded {
  data?: Data19;
}
export interface Payload11 {
  state_name?: string;
  value?: number;
}
export interface Data20 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload11;
  scope?: string;
  space_key?: string;
}
export interface PerfFirstContentfulPaint {
  data?: Data20;
}
export interface Payload12 {
  state_name?: string;
  value?: number;
}
export interface Data21 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload12;
  scope?: string;
  space_key?: string;
}
export interface PerfTimeToInteractive {
  data?: Data21;
}
export interface Data22 {
  action?: string;
  personal_access_token_id?: string;
}
export interface PersonalAccessTokenAction {
  data?: Data22;
}
export interface ReleaseCreated {
  environment_key: string;
  organization_key: string;
  release_id: string;
  space_key: string;
}
export interface ReleaseDialogBox {
  action: string;
  environment_key: string;
  organization_key: string;
  purpose: string;
  space_key: string;
}
export interface ReleaseEntityAdded {
  asset_count: number;
  entry_count: number;
  environment_key: string;
  organization_key: string;
  release_id: string;
  space_key: string;
}
export interface ReleaseEntityRemoved {
  entity_id: string;
  entity_type: string;
  environment_key: string;
  organization_key: string;
  release_id: string;
  space_key: string;
}
export interface ReleasePublished {
  asset_count: number;
  entry_count: number;
  environment_key: string;
  organization_key: string;
  release_id: string;
  space_key: string;
}
export interface ReleaseScheduleCanceled {
  environment_key: string;
  job_id: string;
  organization_key: string;
  release_id: string;
  space_key: string;
}
export interface ReleaseScheduleCreated {
  action: string;
  asset_count: number;
  entry_count: number;
  environment_key: string;
  job_id: string;
  organization_key: string;
  release_id: string;
  scheduled_for: number;
  space_key: string;
}
export interface ReleaseTrashed {
  environment_key: string;
  organization_key: string;
  release_id: string;
  space_key: string;
}
export interface SearchEntryClicked {
  entity_type?: string;
  environment_key?: string;
  index?: number;
  organization_key?: string;
  result_count?: number;
  search_filters?: string[];
  search_query?: string;
  sequence_key?: string;
  space_key?: string;
}
export interface SearchFilterAdded {
  entity_type?: string;
  environment_key?: string;
  filter?: string;
  organization_key?: string;
  result_count?: number;
  search_filters?: string[];
  search_query?: string;
  sequence_key?: string;
  space_key?: string;
}
export interface SearchFilterRemoved {
  entity_type?: string;
  environment_key?: string;
  filter?: string;
  organization_key?: string;
  result_count?: number;
  search_filters?: string[];
  search_query?: string;
  sequence_key?: string;
  space_key?: string;
}
export interface SearchQueryChanged {
  entity_type?: string;
  environment_key?: string;
  organization_key?: string;
  result_count?: number;
  search_filters?: string[];
  search_query?: string;
  sequence_key?: string;
  space_key?: string;
}
export interface SearchSearchPerformed {
  content_type_id?: any | null;
  entity_type?: string;
  environment_key?: string;
  organization_key?: string;
  result_count?: number;
  search_filters?: string[];
  search_query?: string;
  sequence_key?: string;
  space_key?: string;
}
export interface SearchViewCreated {
  content_type_id?: any | null;
  entity_type?: string;
  environment_key?: string;
  folder_id?: string;
  folder_title?: string;
  organization_key?: string;
  search_filters?: string[];
  search_query?: string;
  space_key?: string;
  view_id?: string;
  view_type?: string;
}
export interface SearchViewDeleted {
  entity_type?: string;
  environment_key?: string;
  organization_key?: string;
  space_key?: string;
  view_id?: string;
  view_type?: string;
}
export interface SearchViewLoaded {
  content_type_id?: any | null;
  entity_type?: string;
  environment_key?: string;
  organization_key?: string;
  result_count?: number;
  search_filters?: string[];
  search_query?: string;
  sequence_key?: string;
  space_key?: string;
  view_id?: string;
  view_roles?: any | null;
  view_title?: string;
  view_type?: string;
}
export interface Payload13 {
  cma_entity_version?: number;
  entity_id?: string;
  entity_type?: string;
  share_js_doc_compressed_version?: number;
  share_js_doc_version?: number;
}
export interface SharejsCmaEntityVersionMismatch {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload13;
  scope?: string;
  space_key?: string;
}
export interface SpaceCreate {
  contexts?: string;
}
export interface Payload14 {
  num_err?: number;
  num_success?: number;
}
export interface Data23 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload14;
  scope?: string;
  space_key?: string;
}
export interface TeamsInSpaceUsersAdded {
  data?: Data23;
}
export interface AdditionalData {
  character_count_after?: number;
  character_count_before?: number;
  character_count_selection?: number;
  link_type?: string;
  mark_type?: string;
  node_type?: string;
}
export interface Data24 {
  action?: string;
  action_origin?: string;
  additional_data?: AdditionalData;
  character_count_after?: number;
  character_count_before?: any | null;
  character_count_selection?: any | null;
  content_type_id?: string;
  editor_name?: string;
  entry_id?: string;
  environment_key?: string;
  field_id?: string;
  field_locale?: string;
  is_fullscreen?: boolean;
  organization_key?: string;
  space_key?: string;
}
export interface TextEditorAction {
  data?: Data24;
  schema?: string;
}
export interface Payload15 {
  event?: string;
}
export interface Data25 {
  action?: string;
  environment_key?: string;
  organization_key?: string;
  payload?: Payload15;
  scope?: string;
  space_key?: string;
}
export interface TrackingInvalidEvent {
  data?: Data25;
}
export interface Data26 {
  app_definition_id?: string;
  environment?: string;
  environment_key?: string;
  organization_key?: string;
  space_key?: string;
  user_id?: string;
}
export interface WidgetRendererFallbackRendered {
  data?: Data26;
}
export interface Data27 {
  app_definition_id?: string;
  environment?: string;
  environment_key?: string;
  organization_key?: string;
  space_key?: string;
  user_id?: string;
}
export interface WidgetRendererFallbackWarningShown {
  data?: Data27;
}

export type ViolationHandler = (
  message: Record<string, any>,
  violations: Ajv.ErrorObject[]
) => void;

/**
 * The default handler that is fired if none is supplied with setTypewriterOptions.
 * This handler will log a warning message to the console.
 */
export const defaultValidationErrorHandler: ViolationHandler = (message, violations) => {
  const msg = JSON.stringify(
    {
      type: 'Typewriter JSON Schema Validation Error',
      description:
        `You made an analytics call (${message.event}) using Typewriter that doesn't match the ` +
        'Tracking Plan spec.',
      errors: violations,
    },
    undefined,
    2
  );

  console.warn(msg);
};

let onViolation = defaultValidationErrorHandler;

let analytics: () => SegmentAnalytics.AnalyticsJS | undefined = () => {
  return window.analytics;
};

/** Options to customize the runtime behavior of a Typewriter client. */
export interface TypewriterOptions {
  /**
   * Underlying analytics instance where analytics calls are forwarded on to.
   * Defaults to window.analytics.
   */
  analytics?: SegmentAnalytics.AnalyticsJS;
  /**
   * Handler fired when if an event does not match its spec. This handler
   * does not fire in production mode, because it requires inlining the full
   * JSON Schema spec for each event in your Tracking Plan.
   *
   * By default, it will throw errors if NODE_ENV = "test" so that tests will fail
   * if a message does not match the spec. Otherwise, errors will be logged to stderr.
   */
  onViolation?: ViolationHandler;
}

/**
 * Updates the run-time configuration of this Typewriter client.
 *
 * @param {TypewriterOptions} options - the options to upsert
 *
 * @typedef {Object} TypewriterOptions
 * @property {Segment.AnalyticsJS} [analytics] - Underlying analytics instance where analytics
 * 		calls are forwarded on to. Defaults to window.analytics.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
export function setTypewriterOptions(options: TypewriterOptions) {
  analytics = options.analytics ? () => options.analytics || window.analytics : analytics;
  onViolation = options.onViolation || onViolation;
}

/**
 * Validates a message against a JSON Schema using Ajv. If the message
 * is invalid, the `onViolation` handler will be called.
 */
function validateAgainstSchema(message: Record<string, any>, schema: object) {
  const ajv = new Ajv({ schemaId: 'auto', allErrors: true, verbose: true });
  ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-06.json'));
  ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-04.json'));

  if (!ajv.validate(schema, message) && ajv.errors) {
    onViolation(message, ajv.errors);
  }
}

/**
 * Helper to attach metadata on Typewriter to outbound requests.
 * This is used for attribution and debugging by the Segment team.
 */
function withTypewriterContext(message: Segment.Options = {}): Segment.Options {
  return {
    ...message,
    context: {
      ...(message.context || {}),
      typewriter: {
        language: 'typescript',
        version: '7.4.1',
      },
    },
  };
}

/**
 * @typedef Payload
 * @property {boolean} [has_inaccessible_tasks] -
 * @property {number} [num_pending_tasks] -
 * @property {number} [num_visible_pending_tasks] -
 */
/**
 * @typedef Data
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef AccountDropdownPendingTasksFetched
 * @property {Data} [data] -
 */
/**
 * @typedef Payload1
 * @property {string} [definition_id] -
 */
/**
 * @typedef Data1
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload1} [payload] -
 * @property {string} [scope] -
 */
/**
 * @typedef AppManagementCreated
 * @property {Data1} [data] -
 */
/**
 * @typedef Payload2
 * @property {string} [definition_id] -
 */
/**
 * @typedef Data2
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload2} [payload] -
 * @property {string} [scope] -
 */
/**
 * @typedef AppManagementUpdated
 * @property {Data2} [data] -
 */
/**
 * @typedef Data3
 * @property {string} [app_event_name] -
 * @property {string} [contentful_app_id] -
 * @property {string} [contentful_event_id] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {string} [space_key] -
 */
/**
 * @typedef AppsLifecycleEvent
 * @property {Data3} [data] -
 */
/**
 * @typedef AssetCreated
 * @property {string} [asset_id] -
 * @property {string} [environment] -
 * @property {string} [space_key] -
 * @property {string} [version] -
 */
/**
 * @typedef Data4
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Record<string, any>} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef AssetListAddAssetMultiple
 * @property {Data4} [data] -
 */
/**
 * @typedef Data5
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Record<string, any>} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef AssetListAddAssetSingle
 * @property {Data5} [data] -
 */
/**
 * @typedef AssetPublished
 * @property {string} [asset_id] -
 * @property {string} [environment] -
 * @property {string} [space_key] -
 * @property {string} [version] -
 */
/**
 * @typedef Data6
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {number} [num_edited_entries] -
 * @property {number} [num_published_entries] -
 * @property {string} [organization_key] -
 * @property {string} [parent_entry_id] -
 * @property {number} [ref_count] -
 * @property {string} [space_key] -
 */
/**
 * @typedef BulkEditorClose
 * @property {Data6} [data] -
 */
/**
 * @typedef Data7
 * @property {string} [action] -
 * @property {string} [entry_id] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {string} [parent_entry_id] -
 * @property {number} [ref_count] -
 * @property {string} [space_key] -
 */
/**
 * @typedef BulkEditorEditInEntryEditor
 * @property {Data7} [data] -
 */
/**
 * @typedef Data8
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {string} [parent_entry_id] -
 * @property {number} [ref_count] -
 * @property {string} [space_key] -
 */
/**
 * @typedef BulkEditorOpen
 * @property {Data8} [data] -
 */
/**
 * @typedef Data9
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {string} [parent_entry_id] -
 * @property {number} [ref_count] -
 * @property {string} [space_key] -
 */
/**
 * @typedef BulkEditorOpenSlideIn
 * @property {Data9} [data] -
 */
/**
 * @typedef EditorInterfaceFieldUpdated
 * @property {string} [content_type_id] -
 * @property {string} [environment_key] -
 * @property {string} [field_id] -
 * @property {Record<string, any>} [field_settings] -
 * @property {string} [field_type] -
 * @property {string} [organization_key] -
 * @property {string} [space_key] -
 * @property {string} [widget_id] -
 */
/**
 * @typedef EditorLoaded
 * @property {string} [action] - `init` is triggered every time a slide is loaded. `entity_loaded` is triggered when the editor's main entity is loaded. `sharejs_connected` is triggered when a connection with ShareJS has been established while in case ShareJS is not used for the editor, the more generic `doc_connected` is triggered. `links_rendered` is triggered when all the links (references, media, and rich text embeds / entry hyperlinks) in a slide have been fetched and rendered. `fully_interactive` is trigger when both the links have rendered and the entry has become editable (i.e. ShareJS has connected).
 * @property {string} [environment_key] -
 * @property {number} [link_count] - The total number of links (reference links, media field assets, rich text embedded block and inline entries, rich text embedded block assets, and rich text hyperlinked entries) in the entry on initial load
 * @property {number} [link_field_editor_instance_count] - The overall number of reference and media field instances in an individual entry (1 locale field = 1 instance)
 * @property {number} [load_ms] - Number of milliseconds since the initial load of the entry
 * @property {string} [organization_key] -
 * @property {number} [rich_text_editor_instance_count] - The overall number of rich text editor instances in an individual entry (1 locale field editor = 1 instance)
 * @property {number} [slide_level] - Level of the entry editor within the slides (zero-indexed, -1 if the slide was closed at the time the event is triggered)
 * @property {string} [slide_uuid] - ID uniquely identifying the slide instance - does NOT uniquely identify the entry
 * @property {string} [slides_controller_uuid] - ID uniquely identifying the overall session and therefore all slides loaded around the same time within the same browser tab
 * @property {string} [space_key] -
 * @property {number} [total_slide_count] - The total number of slides open when the entry is initially loaded, default = 0 if there are no slides
 */
/**
 * @typedef Payload3
 * @property {string} [tab_name] -
 */
/**
 * @typedef Data10
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload3} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef EditorWorkbenchTabOpen
 * @property {Data10} [data] -
 */
/**
 * @typedef ElementClick
 * @property {string} [contexts] -
 * @property {string} [element_id] -
 * @property {string} [environment_key] -
 * @property {string} [from_state] -
 * @property {string} [group_id] -
 * @property {string} [organization_key] -
 * @property {string} [space_key] -
 */
/**
 * @typedef EntryPublish
 * @property {string} [action] -
 * @property {string} [content_type_id] -
 * @property {string} [contexts] -
 * @property {number} [entry_ct_entry_reference_fields_count] -
 * @property {string} [entry_id] -
 * @property {string} [event_origin] -
 * @property {boolean} [has_legacy_extensions] -
 * @property {boolean} [is_default] -
 * @property {string} [organization_key] -
 * @property {string} [space_key] -
 * @property {number} [version] -
 */
/**
 * @typedef Payload4
 * @property {number} [circular_references_count] -
 * @property {string} [entity_id] -
 * @property {number} [references_depth] -
 * @property {number[]} [references_per_level] -
 */
/**
 * @typedef Data11
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload4} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef EntryReferencesDialogOpen
 * @property {Data11} [data] -
 */
/**
 * @typedef Payload5
 * @property {string} [entity_id] -
 * @property {number} [references_count] -
 */
/**
 * @typedef Data12
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload5} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef EntryReferencesPublish
 * @property {Data12} [data] -
 */
/**
 * @typedef Payload6
 * @property {string} [entity_id] -
 * @property {number} [references_count] -
 */
/**
 * @typedef Data13
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload6} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef EntryReferencesValidate
 * @property {Data13} [data] -
 */
/**
 * @typedef ExperimentStarted
 * @property {string} [environment_key] -
 * @property {string} experiment_id - The experiment name the current user is part of
 * @property {string} experiment_variation - The experiment variation the current user is assigned to
 * @property {string} [organization_key] - Current organization key
 * @property {string} [space_key] - Current space key
 */
/**
 * @typedef GlobalAppLoaded
 * @property {string} [action] -
 * @property {string} [contexts] -
 * @property {string} [organization_key] -
 * @property {string} [space_key] -
 */
/**
 * @typedef Data14
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [name] -
 * @property {string} [organization_key] -
 * @property {string} [purpose] -
 * @property {string} [space_key] -
 */
/**
 * @typedef GlobalDialog
 * @property {Data14} [data] -
 * @property {string} [schema] -
 */
/**
 * @typedef GlobalSpaceChanged
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Record<string, any>} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef GlobalSpaceLeft
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Record<string, any>} [payload] -
 * @property {string} [scope] -
 */
/**
 * @typedef FromStateParams
 * @property {any | null} [accepted_permissions] -
 * @property {boolean} [add_to_context] -
 * @property {string} [api_key_id] -
 * @property {any | null} [app_id] -
 * @property {string} [asset_id] -
 * @property {string} [content_type_id] -
 * @property {string} [definition_id] -
 * @property {string} [entry_id] -
 * @property {string} [environment_key] -
 * @property {boolean} [ignore_leave_confirmation] -
 * @property {string} [invitation_id] -
 * @property {string} [jump_to_role] -
 * @property {string} [locale_id] -
 * @property {any | null} [org_id] -
 * @property {any | null} [org_owner_or_admin] -
 * @property {string} [path_suffix] -
 * @property {any | null} [referrer] -
 * @property {string} [space_key] -
 * @property {string} [tab] -
 * @property {any | null} [template_id] -
 * @property {string} [user_id] -
 * @property {string} [webhook_id] -
 */
/**
 * @typedef ToStateParams
 * @property {any | null} [accepted_permissions] -
 * @property {boolean} [add_to_context] -
 * @property {string} [api_key_id] -
 * @property {any | null} [app_id] -
 * @property {string} [asset_id] -
 * @property {string} [content_type_id] -
 * @property {string} [definition_id] -
 * @property {string} [entry_id] -
 * @property {string} [environment_key] -
 * @property {boolean} [ignore_leave_confirmation] -
 * @property {string} [jump_to_role] -
 * @property {string} [locale_id] -
 * @property {string} [org_id] -
 * @property {any | null} [org_owner_or_admin] -
 * @property {string} [path_suffix] -
 * @property {any | null} [referrer] -
 * @property {string} [space_key] -
 * @property {string} [tab] -
 * @property {any | null} [template_id] -
 * @property {string} [user_id] -
 * @property {string} [webhook_id] -
 */
/**
 * @typedef Data15
 * @property {string} [from_state] -
 * @property {FromStateParams} [from_state_params] -
 * @property {string} [organization_key] -
 * @property {string} [space_key] -
 * @property {string} [to_state] -
 * @property {ToStateParams} [to_state_params] -
 */
/**
 * @typedef GlobalStateChanged
 * @property {Data15} [data] -
 */
/**
 * @typedef Payload7
 * @property {string} [dialog_action] -
 * @property {string} [dialog_session_id] -
 * @property {string} [entity_id] -
 * @property {string} [entity_type] -
 * @property {number} [incoming_links_count] -
 */
/**
 * @typedef Data16
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload7} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef IncomingLinksDialogConfirm
 * @property {Data16} [data] -
 */
/**
 * @typedef Payload8
 * @property {string} [dialog_action] -
 * @property {string} [dialog_session_id] -
 * @property {string} [entity_id] -
 * @property {string} [entity_type] -
 * @property {number} [incoming_links_count] -
 */
/**
 * @typedef Data17
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload8} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef IncomingLinksDialogOpen
 * @property {Data17} [data] -
 */
/**
 * @typedef Payload9
 * @property {string} [entity_id] -
 * @property {string} [entity_type] -
 * @property {string[]} [incoming_link_ids] -
 * @property {number} [incoming_links_count] -
 */
/**
 * @typedef Data18
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload9} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef IncomingLinksQuery
 * @property {Data18} [data] -
 */
/**
 * @typedef Payload10
 * @property {string} [state_name] -
 * @property {number} [value] -
 */
/**
 * @typedef Data19
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload10} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef PerfDomContentLoaded
 * @property {Data19} [data] -
 */
/**
 * @typedef Payload11
 * @property {string} [state_name] -
 * @property {number} [value] -
 */
/**
 * @typedef Data20
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload11} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef PerfFirstContentfulPaint
 * @property {Data20} [data] -
 */
/**
 * @typedef Payload12
 * @property {string} [state_name] -
 * @property {number} [value] -
 */
/**
 * @typedef Data21
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload12} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef PerfTimeToInteractive
 * @property {Data21} [data] -
 */
/**
 * @typedef Data22
 * @property {string} [action] -
 * @property {string} [personal_access_token_id] -
 */
/**
 * @typedef PersonalAccessTokenAction
 * @property {Data22} [data] -
 */
/**
 * @typedef ReleaseCreated
 * @property {string} environment_key -
 * @property {string} organization_key -
 * @property {string} release_id -
 * @property {string} space_key -
 */
/**
 * @typedef ReleaseDialogBox
 * @property {string} action -
 * @property {string} environment_key -
 * @property {string} organization_key -
 * @property {string} purpose -
 * @property {string} space_key -
 */
/**
 * @typedef ReleaseEntityAdded
 * @property {number} asset_count -
 * @property {number} entry_count -
 * @property {string} environment_key -
 * @property {string} organization_key -
 * @property {string} release_id -
 * @property {string} space_key -
 */
/**
 * @typedef ReleaseEntityRemoved
 * @property {string} entity_id -
 * @property {string} entity_type -
 * @property {string} environment_key -
 * @property {string} organization_key -
 * @property {string} release_id -
 * @property {string} space_key -
 */
/**
 * @typedef ReleasePublished
 * @property {number} asset_count -
 * @property {number} entry_count -
 * @property {string} environment_key -
 * @property {string} organization_key -
 * @property {string} release_id -
 * @property {string} space_key -
 */
/**
 * @typedef ReleaseScheduleCanceled
 * @property {string} environment_key -
 * @property {string} job_id -
 * @property {string} organization_key -
 * @property {string} release_id -
 * @property {string} space_key -
 */
/**
 * @typedef ReleaseScheduleCreated
 * @property {string} action -
 * @property {number} asset_count -
 * @property {number} entry_count -
 * @property {string} environment_key -
 * @property {string} job_id -
 * @property {string} organization_key -
 * @property {string} release_id -
 * @property {number} scheduled_for -
 * @property {string} space_key -
 */
/**
 * @typedef ReleaseTrashed
 * @property {string} environment_key -
 * @property {string} organization_key -
 * @property {string} release_id -
 * @property {string} space_key -
 */
/**
 * @typedef SearchEntryClicked
 * @property {string} [entity_type] -
 * @property {string} [environment_key] -
 * @property {number} [index] -
 * @property {string} [organization_key] -
 * @property {number} [result_count] -
 * @property {string[]} [search_filters] -
 * @property {string} [search_query] -
 * @property {string} [sequence_key] -
 * @property {string} [space_key] -
 */
/**
 * @typedef SearchFilterAdded
 * @property {string} [entity_type] -
 * @property {string} [environment_key] -
 * @property {string} [filter] -
 * @property {string} [organization_key] -
 * @property {number} [result_count] -
 * @property {string[]} [search_filters] -
 * @property {string} [search_query] -
 * @property {string} [sequence_key] -
 * @property {string} [space_key] -
 */
/**
 * @typedef SearchFilterRemoved
 * @property {string} [entity_type] -
 * @property {string} [environment_key] -
 * @property {string} [filter] -
 * @property {string} [organization_key] -
 * @property {number} [result_count] -
 * @property {string[]} [search_filters] -
 * @property {string} [search_query] -
 * @property {string} [sequence_key] -
 * @property {string} [space_key] -
 */
/**
 * @typedef SearchQueryChanged
 * @property {string} [entity_type] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {number} [result_count] -
 * @property {string[]} [search_filters] -
 * @property {string} [search_query] -
 * @property {string} [sequence_key] -
 * @property {string} [space_key] -
 */
/**
 * @typedef SearchSearchPerformed
 * @property {any | null} [content_type_id] -
 * @property {string} [entity_type] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {number} [result_count] -
 * @property {string[]} [search_filters] -
 * @property {string} [search_query] -
 * @property {string} [sequence_key] -
 * @property {string} [space_key] -
 */
/**
 * @typedef SearchViewCreated
 * @property {any | null} [content_type_id] -
 * @property {string} [entity_type] -
 * @property {string} [environment_key] -
 * @property {string} [folder_id] -
 * @property {string} [folder_title] -
 * @property {string} [organization_key] -
 * @property {string[]} [search_filters] -
 * @property {string} [search_query] -
 * @property {string} [space_key] -
 * @property {string} [view_id] -
 * @property {string} [view_type] -
 */
/**
 * @typedef SearchViewDeleted
 * @property {string} [entity_type] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {string} [space_key] -
 * @property {string} [view_id] -
 * @property {string} [view_type] -
 */
/**
 * @typedef SearchViewLoaded
 * @property {any | null} [content_type_id] -
 * @property {string} [entity_type] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {number} [result_count] -
 * @property {string[]} [search_filters] -
 * @property {string} [search_query] -
 * @property {string} [sequence_key] -
 * @property {string} [space_key] -
 * @property {string} [view_id] -
 * @property {any | null} [view_roles] -
 * @property {string} [view_title] -
 * @property {string} [view_type] -
 */
/**
 * @typedef Payload13
 * @property {number} [cma_entity_version] -
 * @property {string} [entity_id] -
 * @property {string} [entity_type] -
 * @property {number} [share_js_doc_compressed_version] -
 * @property {number} [share_js_doc_version] -
 */
/**
 * @typedef SharejsCmaEntityVersionMismatch
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload13} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef SpaceCreate
 * @property {string} [contexts] -
 */
/**
 * @typedef Payload14
 * @property {number} [num_err] -
 * @property {number} [num_success] -
 */
/**
 * @typedef Data23
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload14} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef TeamsInSpaceUsersAdded
 * @property {Data23} [data] -
 */
/**
 * @typedef AdditionalData
 * @property {number} [character_count_after] -
 * @property {number} [character_count_before] -
 * @property {number} [character_count_selection] -
 * @property {string} [link_type] -
 * @property {string} [mark_type] -
 * @property {string} [node_type] -
 */
/**
 * @typedef Data24
 * @property {string} [action] -
 * @property {string} [action_origin] -
 * @property {AdditionalData} [additional_data] -
 * @property {number} [character_count_after] -
 * @property {any | null} [character_count_before] -
 * @property {any | null} [character_count_selection] -
 * @property {string} [content_type_id] -
 * @property {string} [editor_name] -
 * @property {string} [entry_id] -
 * @property {string} [environment_key] -
 * @property {string} [field_id] -
 * @property {string} [field_locale] -
 * @property {boolean} [is_fullscreen] -
 * @property {string} [organization_key] -
 * @property {string} [space_key] -
 */
/**
 * @typedef TextEditorAction
 * @property {Data24} [data] -
 * @property {string} [schema] -
 */
/**
 * @typedef Payload15
 * @property {string} [event] -
 */
/**
 * @typedef Data25
 * @property {string} [action] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {Payload15} [payload] -
 * @property {string} [scope] -
 * @property {string} [space_key] -
 */
/**
 * @typedef TrackingInvalidEvent
 * @property {Data25} [data] -
 */
/**
 * @typedef Data26
 * @property {string} [app_definition_id] -
 * @property {string} [environment] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {string} [space_key] -
 * @property {string} [user_id] -
 */
/**
 * @typedef WidgetRendererFallbackRendered
 * @property {Data26} [data] -
 */
/**
 * @typedef Data27
 * @property {string} [app_definition_id] -
 * @property {string} [environment] -
 * @property {string} [environment_key] -
 * @property {string} [organization_key] -
 * @property {string} [space_key] -
 * @property {string} [user_id] -
 */
/**
 * @typedef WidgetRendererFallbackWarningShown
 * @property {Data27} [data] -
 */

/**
 * Fires a 'account_dropdown:pending_tasks_fetched' track call.
 *
 * @param {AccountDropdownPendingTasksFetched} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function accountDropdownPendingTasksFetched(
  props?: AccountDropdownPendingTasksFetched,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  has_inaccessible_tasks: {
                    type: ['boolean'],
                  },
                  num_pending_tasks: {
                    type: ['integer'],
                  },
                  num_visible_pending_tasks: {
                    type: ['integer'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'account_dropdown:pending_tasks_fetched',
    type: 'object',
  };
  const message = {
    event: 'account_dropdown:pending_tasks_fetched',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track(
      'account_dropdown:pending_tasks_fetched',
      props || {},
      withTypewriterContext(options),
      callback
    );
  }
}
/**
 * ApiKey schema
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function apiKey(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'ApiKey schema',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          api_key_id: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string', 'null'],
          },
          space_key: {
            type: ['string'],
          },
          version: {
            type: ['integer', 'null'],
          },
        },
        required: ['space_key', 'action', 'api_key_id'],
      },
      traits: {},
    },
    title: 'api_key',
  };
  const message = {
    event: 'api_key',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('api_key', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Records an app definition lifecycle event
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function appDefinition(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Records an app definition lifecycle event',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            description: 'Type of action event',
            type: 'string',
          },
          app_definition_id: {
            description: 'Refers to app definition id',
            type: 'string',
          },
          created_at: {
            description: 'App definition creation timestamp',
            type: 'string',
          },
          deleted_at: {
            description: 'App definition delete timestamp',
            type: 'string',
          },
          has_config: {
            description: 'Whether the app has configuration screen',
            type: 'boolean',
          },
          is_public: {
            description: 'Public or private app',
            type: 'boolean',
          },
          locations: {
            description: 'Locations enabled for the app',
            type: 'array',
          },
          name: {
            description: 'Name of the app',
            type: 'string',
          },
          organization_key: {
            description: 'Refers to organization key',
            type: 'string',
          },
          src: {
            description: 'Host domain for the app',
            type: 'string',
          },
          updated_at: {
            description: 'App definition update timestamp',
            type: 'string',
          },
          user_agent: {
            description: 'Refers to the original request user-agent',
            type: 'string',
          },
        },
        required: [
          'action',
          'organization_key',
          'app_definition_id',
          'name',
          'src',
          'locations',
          'is_public',
          'has_config',
        ],
      },
      traits: {},
    },
    title: 'app_definition',
  };
  const message = {
    event: 'app_definition',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('app_definition', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Records an app installation lifecycle event
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function appInstallation(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Records an app installation lifecycle event',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            description: 'Type of action event',
            type: 'string',
          },
          app_definition_id: {
            description: 'Refers to app_id',
            type: 'string',
          },
          created_at: {
            description: 'App creation timestamp',
            type: ['string', 'null'],
          },
          deleted_at: {
            description: 'App delete timestamp',
            type: ['string', 'null'],
          },
          environment_key: {
            description: 'Refers to environment_key',
            type: 'string',
          },
          space_key: {
            description: 'Refers to space_key',
            type: 'string',
          },
          updated_at: {
            description: 'App update timestamp',
            type: ['string', 'null'],
          },
          user_agent: {
            description: 'Refers to the original request user-agent',
            type: 'string',
          },
        },
        required: ['space_key', 'environment_key', 'app_definition_id'],
      },
      traits: {},
    },
    title: 'app_installation',
  };
  const message = {
    event: 'app_installation',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('app_installation', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Records an event in App lifecycle
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function appLifecycleEvent(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Records an event in App lifecycle',
    properties: {
      context: {},
      properties: {
        properties: {
          app_event_name: {
            description: 'Name of lifecycle event',
            type: 'string',
          },
          contentful_app_id: {
            description: 'ID of Contentful App',
            type: 'string',
          },
          contentful_event_id: {
            description: 'Web App generated correlation ID',
            type: 'string',
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            description: 'Refers to organization_key',
            type: ['string', 'null'],
          },
          space_key: {
            description: 'Refers to space_key',
            type: 'string',
          },
        },
        required: ['space_key', 'contentful_event_id', 'contentful_app_id', 'app_event_name'],
      },
      traits: {},
    },
    title: 'app_lifecycle_event',
  };
  const message = {
    event: 'app_lifecycle_event',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('app_lifecycle_event', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'app_management:created' track call.
 *
 * @param {AppManagementCreated} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function appManagementCreated(
  props?: AppManagementCreated,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  definition_id: {
                    type: ['string'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'app_management:created',
    type: 'object',
  };
  const message = {
    event: 'app_management:created',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('app_management:created', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'app_management:updated' track call.
 *
 * @param {AppManagementUpdated} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function appManagementUpdated(
  props?: AppManagementUpdated,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  definition_id: {
                    type: ['string'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'app_management:updated',
    type: 'object',
  };
  const message = {
    event: 'app_management:updated',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('app_management:updated', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Web app opened by visiting app.contentful.com
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function appOpen(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Web app opened by visiting app.contentful.com',
    properties: {
      context: {},
      properties: {
        properties: {
          environment_key: {
            type: 'string',
          },
          organization_key: {
            type: 'string',
          },
          space_key: {
            type: 'string',
          },
        },
      },
      traits: {},
    },
    title: 'app_open',
  };
  const message = {
    event: 'app_open',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('app_open', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Event fired when the example app opens
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function appTheExampleAppOpen(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Event fired when the example app opens',
    properties: {
      context: {},
      properties: {
        properties: {
          app_framework: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          sdk_language_used: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
        },
        required: ['space_key', 'sdk_language_used', 'app_framework'],
      },
      traits: {},
    },
    title: 'app_the_example_app_open',
  };
  const message = {
    event: 'app_the_example_app_open',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('app_the_example_app_open', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Records a reason for App uninstallation
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function appUninstallationReason(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Records a reason for App uninstallation',
    properties: {
      context: {},
      properties: {
        properties: {
          contentful_app_id: {
            description: 'ID of Contentful App',
            type: 'string',
          },
          contentful_event_id: {
            description: 'Web App generated correlation ID',
            type: 'string',
          },
          custom: {
            description: 'Is reason custom or not',
            type: 'boolean',
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            description: 'Refers to organization_key',
            type: ['string', 'null'],
          },
          reason: {
            description: 'Reason for uninstalling',
            type: 'string',
          },
          space_key: {
            description: 'Refers to space_key',
            type: 'string',
          },
        },
        required: ['space_key', 'contentful_event_id', 'contentful_app_id', 'custom', 'reason'],
      },
      traits: {},
    },
    title: 'app_uninstallation_reason',
  };
  const message = {
    event: 'app_uninstallation_reason',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('app_uninstallation_reason', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'apps:lifecycle_event' track call.
 *
 * @param {AppsLifecycleEvent} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function appsLifecycleEvent(
  props?: AppsLifecycleEvent,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              app_event_name: {
                type: ['string'],
              },
              contentful_app_id: {
                type: ['string'],
              },
              contentful_event_id: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'apps:lifecycle_event',
    type: 'object',
  };
  const message = {
    event: 'apps:lifecycle_event',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('apps:lifecycle_event', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'asset_created' track call.
 *
 * @param {AssetCreated} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function assetCreated(
  props?: AssetCreated,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          asset_id: {
            type: ['string'],
          },
          environment: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          version: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'asset_created',
    type: 'object',
  };
  const message = {
    event: 'asset_created',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('asset_created', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'asset_list:add_asset_multiple' track call.
 *
 * @param {AssetListAddAssetMultiple} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function assetListAddAssetMultiple(
  props?: AssetListAddAssetMultiple,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                type: ['object'],
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'asset_list:add_asset_multiple',
    type: 'object',
  };
  const message = {
    event: 'asset_list:add_asset_multiple',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('asset_list:add_asset_multiple', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'asset_list:add_asset_single' track call.
 *
 * @param {AssetListAddAssetSingle} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function assetListAddAssetSingle(
  props?: AssetListAddAssetSingle,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                type: ['object'],
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'asset_list:add_asset_single',
    type: 'object',
  };
  const message = {
    event: 'asset_list:add_asset_single',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('asset_list:add_asset_single', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'asset_published' track call.
 *
 * @param {AssetPublished} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function assetPublished(
  props?: AssetPublished,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          asset_id: {
            type: ['string'],
          },
          environment: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          version: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'asset_published',
    type: 'object',
  };
  const message = {
    event: 'asset_published',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('asset_published', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Tracks usage of boilerplate projects
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function boilerplate(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Tracks usage of boilerplate projects',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          platform: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
        },
        required: ['organization_key', 'space_key', 'action', 'platform'],
      },
      traits: {},
    },
    title: 'boilerplate',
  };
  const message = {
    event: 'boilerplate',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('boilerplate', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'bulk_editor:close' track call.
 *
 * @param {BulkEditorClose} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function bulkEditorClose(
  props?: BulkEditorClose,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              num_edited_entries: {
                type: ['integer'],
              },
              num_published_entries: {
                type: ['integer'],
              },
              organization_key: {
                type: ['string'],
              },
              parent_entry_id: {
                type: ['string'],
              },
              ref_count: {
                type: ['integer'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'bulk_editor:close',
    type: 'object',
  };
  const message = {
    event: 'bulk_editor:close',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('bulk_editor:close', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'bulk_editor:edit_in_entry_editor' track call.
 *
 * @param {BulkEditorEditInEntryEditor} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function bulkEditorEditInEntryEditor(
  props?: BulkEditorEditInEntryEditor,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              entry_id: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              parent_entry_id: {
                type: ['string'],
              },
              ref_count: {
                type: ['integer'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'bulk_editor:edit_in_entry_editor',
    type: 'object',
  };
  const message = {
    event: 'bulk_editor:edit_in_entry_editor',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track(
      'bulk_editor:edit_in_entry_editor',
      props || {},
      withTypewriterContext(options),
      callback
    );
  }
}
/**
 * Fires a 'bulk_editor:open' track call.
 *
 * @param {BulkEditorOpen} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function bulkEditorOpen(
  props?: BulkEditorOpen,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              parent_entry_id: {
                type: ['string'],
              },
              ref_count: {
                type: ['integer'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'bulk_editor:open',
    type: 'object',
  };
  const message = {
    event: 'bulk_editor:open',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('bulk_editor:open', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'bulk_editor:open_slide_in' track call.
 *
 * @param {BulkEditorOpenSlideIn} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function bulkEditorOpenSlideIn(
  props?: BulkEditorOpenSlideIn,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              parent_entry_id: {
                type: ['string'],
              },
              ref_count: {
                type: ['integer'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'bulk_editor:open_slide_in',
    type: 'object',
  };
  const message = {
    event: 'bulk_editor:open_slide_in',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('bulk_editor:open_slide_in', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema for any event that has to do with content preview in our webapp
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function contentPreview(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema for any event that has to do with content preview in our webapp',
    properties: {
      context: {},
      properties: {
        properties: {
          content_type_id: {
            type: ['string'],
          },
          content_type_name: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          preview_id: {
            type: ['string'],
          },
          preview_name: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
        },
        required: ['organization_key', 'space_key', 'preview_name', 'preview_id'],
      },
      traits: {},
    },
    title: 'content_preview',
  };
  const message = {
    event: 'content_preview',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('content_preview', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * ContentTyppe schema
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function contentType(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'ContentTyppe schema',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          content_type_id: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string', 'null'],
          },
          revision: {
            type: ['integer', 'null'],
          },
          space_key: {
            type: ['string'],
          },
          version: {
            type: ['integer', 'null'],
          },
        },
        required: ['space_key', 'content_type_id', 'action'],
      },
      traits: {},
    },
    title: 'content_type',
  };
  const message = {
    event: 'content_type',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('content_type', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Emitted when a job is triggered
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function dialog(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Emitted when a job is triggered',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            description: 'action performed in relationship with the dialog. Example: (dialog) open',
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          funnel_id: {
            description: 'unique id generated, to make funnel analytics way simpler',
            type: ['string', 'null'],
          },
          name: {
            description: 'name identifying the current dialog name. Example: jobs_create',
            type: ['string'],
          },
          organization_key: {
            description: 'refers to GK organization key',
            type: ['string'],
          },
          purpose: {
            description:
              'if known, identifies what the dialog is intended to fulfill. Example: Entry.publish',
            type: ['string', 'null'],
          },
          space_key: {
            description: 'refers to GK space key',
            type: ['string'],
          },
        },
        required: ['organization_key', 'space_key', 'name', 'action'],
      },
      traits: {},
    },
    title: 'dialog',
  };
  const message = {
    event: 'dialog',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('dialog', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'editor_interface_field_updated' track call.
 *
 * @param {EditorInterfaceFieldUpdated} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function editorInterfaceFieldUpdated(
  props?: EditorInterfaceFieldUpdated,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          content_type_id: {
            description: '',
            type: 'string',
          },
          environment_key: {
            description: '',
            type: 'string',
          },
          field_id: {
            description: '',
            type: 'string',
          },
          field_settings: {
            description: '',
            type: 'object',
          },
          field_type: {
            description: '',
            type: 'string',
          },
          organization_key: {
            description: '',
            type: 'string',
          },
          space_key: {
            description: '',
            type: 'string',
          },
          widget_id: {
            description: '',
            type: 'string',
          },
        },
        type: 'object',
      },
      traits: {
        type: 'object',
      },
    },
    title: 'editor_interface_field_updated',
    type: 'object',
  };
  const message = {
    event: 'editor_interface_field_updated',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track(
      'editor_interface_field_updated',
      props || {},
      withTypewriterContext(options),
      callback
    );
  }
}
/**
 * Fires a 'editor_loaded' track call.
 *
 * @param {EditorLoaded} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function editorLoaded(
  props?: EditorLoaded,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            description:
              "`init` is triggered every time a slide is loaded. `entity_loaded` is triggered when the editor's main entity is loaded. `sharejs_connected` is triggered when a connection with ShareJS has been established while in case ShareJS is not used for the editor, the more generic `doc_connected` is triggered. `links_rendered` is triggered when all the links (references, media, and rich text embeds / entry hyperlinks) in a slide have been fetched and rendered. `fully_interactive` is trigger when both the links have rendered and the entry has become editable (i.e. ShareJS has connected).",
            enum: [
              'doc_connected',
              'entity_loaded',
              'fully_interactive',
              'init',
              'links_rendered',
              'sharejs_connected',
            ],
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          link_count: {
            description:
              'The total number of links (reference links, media field assets, rich text embedded block and inline entries, rich text embedded block assets, and rich text hyperlinked entries) in the entry on initial load',
            type: ['integer'],
          },
          link_field_editor_instance_count: {
            description:
              'The overall number of reference and media field instances in an individual entry (1 locale field = 1 instance)',
            type: ['integer'],
          },
          load_ms: {
            description: 'Number of milliseconds since the initial load of the entry',
            type: ['integer'],
          },
          organization_key: {
            type: ['string'],
          },
          rich_text_editor_instance_count: {
            description:
              'The overall number of rich text editor instances in an individual entry (1 locale field editor = 1 instance)',
            type: ['integer'],
          },
          slide_level: {
            description:
              'Level of the entry editor within the slides (zero-indexed, -1 if the slide was closed at the time the event is triggered)',
            type: ['integer'],
          },
          slide_uuid: {
            description:
              'ID uniquely identifying the slide instance - does NOT uniquely identify the entry',
            type: ['string'],
          },
          slides_controller_uuid: {
            description:
              'ID uniquely identifying the overall session and therefore all slides loaded around the same time within the same browser tab',
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          total_slide_count: {
            description:
              'The total number of slides open when the entry is initially loaded, default = 0 if there are no slides',
            type: ['integer'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'editor_loaded',
    type: 'object',
  };
  const message = {
    event: 'editor_loaded',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('editor_loaded', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'editor_workbench:tab_open' track call.
 *
 * @param {EditorWorkbenchTabOpen} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function editorWorkbenchTabOpen(
  props?: EditorWorkbenchTabOpen,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  tab_name: {
                    type: ['string'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'editor_workbench:tab_open',
    type: 'object',
  };
  const message = {
    event: 'editor_workbench:tab_open',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('editor_workbench:tab_open', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'element:click' track call.
 *
 * @param {ElementClick} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function elementClick(
  props?: ElementClick,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          contexts: {
            type: ['string'],
          },
          element_id: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          from_state: {
            type: ['string'],
          },
          group_id: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'element:click',
    type: 'object',
  };
  const message = {
    event: 'element:click',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('element:click', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * ShareJS removal, CMA-only entity editor edit conflicts tracking. This event is tracked when persisting local editor changes fails due to a CMA version mismatch error. `local_entity` refers to the last CMA version of the entity known to the entity editor without local changes and before the conflict. All pending local changes are based on this entity version. `remote_entity` refers to the most recent version of the entity which has caused the version mismatch and thus might have conflicts with the local changes on top of `local_entity`.
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function entityEditorEditConflict(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description:
      'ShareJS removal, CMA-only entity editor edit conflicts tracking. This event is tracked when persisting local editor changes fails due to a CMA version mismatch error. `local_entity` refers to the last CMA version of the entity known to the entity editor without local changes and before the conflict. All pending local changes are based on this entity version. `remote_entity` refers to the most recent version of the entity which has caused the version mismatch and thus might have conflicts with the local changes on top of `local_entity`.',
    properties: {
      context: {},
      properties: {
        properties: {
          auto_conflict_resolution_version: {
            description:
              "Version of our editor's auto conflict resolution version. Should bump this whenever we fit to be able to only compare events of the same implemented version.",
            type: 'integer',
          },
          entity_id: {
            type: 'string',
          },
          entity_type: {
            enum: ['Entry', 'Asset'],
            type: 'string',
          },
          environment_key: {
            type: ['string'],
          },
          is_conflict_auto_resolvable: {
            description:
              "Whether or not the current editor implementation is able to resolve the conflict without the user's input.",
            type: 'boolean',
          },
          local_changes_paths: {
            description:
              'Comma separated paths `path,...` where `path` can be either `fields:${FIELD_ID}:${LOCALE_CODE}` for pending fields changes or `metadata:${NAME}` for pending metadata changes not persisted yet and on top of the `local_entity`. ID/code are public CMA identifiers, not internal CF IDs. Should only be `null` if there are too many paths to be tracked due to `maxLength` constraint.',
            type: ['string', 'null'],
          },
          local_entity_last_fetched_at_tstamp: {
            description:
              'Point in time when the most-up-to-date local in-memory `local_entity` was received by the editor.',
            type: 'string',
          },
          local_entity_state: {
            description: 'The `local_entity` state before any local changes.',
            enum: ['draft', 'published', 'archived', 'inaccessible'],
            type: 'string',
          },
          local_entity_updated_at_tstamp: {
            description: 'entity.sys.updatedAt of the `local_entity`.',
            type: 'string',
          },
          local_entity_version: {
            description: '`entity.sys.version` of the `local_entity`.',
            type: 'integer',
          },
          local_state_change: {
            description:
              'Local pending state update that was not successful due to the conflict. `null` if there was no local state update.',
            enum: ['draft', 'published', 'archived', 'inaccessible', null],
            type: ['string', 'null'],
          },
          organization_key: {
            type: 'string',
          },
          precomputed: {
            properties: {
              local_field_locale_changes_count: {
                description:
                  'Total number of locally changed field locales on top of the `local_entity`: `count(onlyFieldPaths(local_changes_paths))`',
                type: 'integer',
              },
              local_metadata_changes_count: {
                description:
                  'Total number of locally changed metadata properties on top of the `local_entity`: `count(onlyMetadataPaths(local_changes_paths))`',
                type: 'integer',
              },
              remote_field_locale_changes_count: {
                description:
                  'Total number of field locales changed in `remote_entity` compared to `local_entity`: `count(onlyFieldPaths(remote_changes_paths))`',
                type: 'integer',
              },
              remote_metadata_changes_count: {
                description:
                  'Total number of metadata properties changed in `remote_entity` compared to `local_entity`: `count(onlyMetadataPaths(remote_changes_paths))`',
                type: 'integer',
              },
              same_field_locale_conflicts_count: {
                description:
                  'Pre-computed number of conflicts on same field locales: `count(intersection(onlyFieldPaths(local_changes_paths), onlyFieldPaths(remote_changes_paths)))`',
                type: 'integer',
              },
              same_metadata_conflicts_count: {
                description:
                  'Pre-computed number of conflicts on same metadata property: `count(intersection(onlyMetadataPaths(local_changes_paths), onlyMetadataPaths(remote_changes_paths)))`',
                type: 'integer',
              },
            },
            type: ['object'],
          },
          remote_changes_paths: {
            description:
              'Comma separated paths as in `local_changes_paths` but for `remote_entity` fields or metadata with different values from `local_entity`. See `local_changes_paths` description for specifics and `null` case explanation.',
            type: ['string', 'null'],
          },
          remote_entity_state: {
            description: 'The state of the `remote_entity` after the edit conflict.',
            enum: ['draft', 'published', 'archived', 'inaccessible'],
            type: 'string',
          },
          remote_entity_updated_at_tstamp: {
            description: 'entity.sys.updatedAt of the `remote_entity`.',
            type: 'string',
          },
          remote_entity_updated_by_user_id: {
            description: 'entity.sys.updatedBy.sys.id of the `remote_entity`.',
            type: 'string',
          },
          remote_entity_version: {
            description: '`entity.sys.version` of the `remote_entity`.',
            type: 'integer',
          },
          space_key: {
            type: 'string',
          },
        },
        required: [
          'organization_key',
          'space_key',
          'entity_id',
          'entity_type',
          'local_changes_paths',
          'remote_changes_paths',
          'local_state_change',
          'local_entity_state',
          'remote_entity_state',
          'local_entity_version',
          'remote_entity_version',
          'local_entity_last_fetched_at_tstamp',
          'local_entity_updated_at_tstamp',
          'remote_entity_updated_at_tstamp',
          'remote_entity_updated_by_user_id',
          'is_conflict_auto_resolvable',
          'auto_conflict_resolution_version',
        ],
      },
      traits: {},
    },
    title: 'entity_editor_edit_conflict',
  };
  const message = {
    event: 'entity_editor_edit_conflict',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('entity_editor_edit_conflict', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * EXPERIMENT for Snowplow -> Segment migration (hence "_2" suffix) | ShareJS removal, CMA-only entity editor edit conflicts tracking. This event is tracked when persisting local editor changes fails due to a CMA version mismatch error. `local_entity` refers to the last CMA version of the entity known to the entity editor without local changes and before the conflict. All pending local changes are based on this entity version. `remote_entity` refers to the most recent version of the entity which has caused the version mismatch and thus might have conflicts with the local changes on top of `local_entity`.
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function entityEditorEditConflict2(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description:
      'EXPERIMENT for Snowplow -> Segment migration (hence "_2" suffix) | ShareJS removal, CMA-only entity editor edit conflicts tracking. This event is tracked when persisting local editor changes fails due to a CMA version mismatch error. `local_entity` refers to the last CMA version of the entity known to the entity editor without local changes and before the conflict. All pending local changes are based on this entity version. `remote_entity` refers to the most recent version of the entity which has caused the version mismatch and thus might have conflicts with the local changes on top of `local_entity`.',
    properties: {
      context: {},
      properties: {
        properties: {
          auto_conflict_resolution_version: {
            description:
              "Version of our editor's auto conflict resolution version. Should bump this whenever we fit to be able to only compare events of the same implemented version.",
            type: 'integer',
          },
          entity_id: {
            type: 'string',
          },
          entity_type: {
            enum: ['Entry', 'Asset'],
            type: 'string',
          },
          is_conflict_auto_resolvable: {
            description:
              "Whether or not the current editor implementation is able to resolve the conflict without the user's input.",
            type: 'boolean',
          },
          local_changes_paths: {
            description:
              'Comma separated paths `path,...` where `path` can be either `fields:${FIELD_ID}:${LOCALE_CODE}` for pending fields changes or `metadata:${NAME}` for pending metadata changes not persisted yet and on top of the `local_entity`. ID/code are public CMA identifiers, not internal CF IDs. Should only be `null` if there are too many paths to be tracked due to `maxLength` constraint.',
            type: ['string', 'null'],
          },
          local_entity_last_fetched_at_tstamp: {
            description:
              'Point in time when the most-up-to-date local in-memory `local_entity` was received by the editor.',
            type: 'string',
          },
          local_entity_state: {
            description: 'The `local_entity` state before any local changes.',
            enum: ['draft', 'published', 'archived', 'inaccessible'],
            type: 'string',
          },
          local_entity_updated_at_tstamp: {
            description: 'entity.sys.updatedAt of the `local_entity`.',
            type: 'string',
          },
          local_entity_version: {
            description: '`entity.sys.version` of the `local_entity`.',
            type: 'integer',
          },
          local_state_change: {
            description:
              'Local pending state update that was not successful due to the conflict. `null` if there was no local state update.',
            enum: ['draft', 'published', 'archived', 'inaccessible', null],
            type: ['string', 'null'],
          },
          organization_key: {
            type: 'string',
          },
          precomputed: {
            type: ['object'],
          },
          remote_changes_paths: {
            description:
              'Comma separated paths as in `local_changes_paths` but for `remote_entity` fields or metadata with different values from `local_entity`. See `local_changes_paths` description for specifics and `null` case explanation.',
            type: ['string', 'null'],
          },
          remote_entity_state: {
            description: 'The state of the `remote_entity` after the edit conflict.',
            enum: ['draft', 'published', 'archived', 'inaccessible'],
            type: 'string',
          },
          remote_entity_updated_at_tstamp: {
            description: 'entity.sys.updatedAt of the `remote_entity`.',
            type: 'string',
          },
          remote_entity_updated_by_user_id: {
            description: 'entity.sys.updatedBy.sys.id of the `remote_entity`.',
            type: 'string',
          },
          remote_entity_version: {
            description: '`entity.sys.version` of the `remote_entity`.',
            type: 'integer',
          },
          space_key: {
            type: 'string',
          },
        },
        required: [
          'organization_key',
          'space_key',
          'entity_id',
          'entity_type',
          'local_changes_paths',
          'remote_changes_paths',
          'local_state_change',
          'local_entity_state',
          'remote_entity_state',
          'local_entity_version',
          'remote_entity_version',
          'local_entity_last_fetched_at_tstamp',
          'local_entity_updated_at_tstamp',
          'remote_entity_updated_at_tstamp',
          'remote_entity_updated_by_user_id',
          'is_conflict_auto_resolvable',
          'auto_conflict_resolution_version',
        ],
      },
      traits: {},
    },
    title: 'entity_editor_edit_conflict_2',
  };
  const message = {
    event: 'entity_editor_edit_conflict_2',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('entity_editor_edit_conflict_2', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Entry schema
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function entry(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Entry schema',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          content_type_id: {
            type: ['string'],
          },
          entry_id: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string', 'null'],
          },
          revision: {
            type: ['integer', 'null'],
          },
          space_key: {
            type: ['string'],
          },
          version: {
            type: ['integer', 'null'],
          },
        },
        required: ['space_key', 'content_type_id', 'entry_id', 'action'],
      },
      traits: {},
    },
    title: 'entry',
  };
  const message = {
    event: 'entry',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('entry', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'entry:publish' track call.
 *
 * @param {EntryPublish} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function entryPublish(
  props?: EntryPublish,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          content_type_id: {
            type: ['string'],
          },
          contexts: {
            type: ['string'],
          },
          entry_ct_entry_reference_fields_count: {
            type: ['integer'],
          },
          entry_id: {
            type: ['string'],
          },
          event_origin: {
            type: ['string'],
          },
          has_legacy_extensions: {
            type: ['boolean'],
          },
          is_default: {
            type: ['boolean'],
          },
          organization_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          version: {
            type: ['integer'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'entry:publish',
    type: 'object',
  };
  const message = {
    event: 'entry:publish',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('entry:publish', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema of creating an entry in the webapp
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function entryCreate(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema of creating an entry in the webapp',
    properties: {
      context: {},
      properties: {
        properties: {
          entry_ct_entry_reference_fields_count: {
            type: 'integer',
          },
          entry_id: {
            type: 'string',
          },
          environment_key: {
            type: ['string'],
          },
          event_origin: {
            type: 'string',
          },
          organization_key: {
            type: 'string',
          },
          space_key: {
            type: 'string',
          },
        },
        required: ['organization_key', 'space_key'],
      },
      traits: {},
    },
    title: 'entry_create',
  };
  const message = {
    event: 'entry_create',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('entry_create', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'entry_created' track call.
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function entryCreated(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          content_type_id: {
            type: 'string',
          },
          entry_ct_entry_reference_fields_count: {
            type: 'integer',
          },
          entry_ct_fields_count: {
            type: ['integer', 'null'],
          },
          entry_id: {
            type: 'string',
          },
          entry_version: {
            type: 'integer',
          },
          environment_key: {
            type: 'string',
          },
          event_origin: {
            type: 'string',
          },
          organization_key: {
            type: 'string',
          },
          space_key: {
            type: 'string',
          },
        },
        required: ['organization_key', 'space_key'],
      },
      traits: {},
    },
    title: 'entry_created',
  };
  const message = {
    event: 'entry_created',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('entry_created', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema of publishing an entry in the webapp
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function entryPublish1(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema of publishing an entry in the webapp',
    properties: {
      context: {},
      properties: {
        properties: {
          content_type_id: {
            type: 'string',
          },
          entry_ct_entry_reference_fields_count: {
            type: 'integer',
          },
          entry_ct_fields_count: {
            type: ['integer', 'null'],
          },
          entry_id: {
            type: 'string',
          },
          entry_version: {
            type: 'integer',
          },
          environment_key: {
            type: 'string',
          },
          event_origin: {
            type: 'string',
          },
          organization_key: {
            type: 'string',
          },
          space_key: {
            type: 'string',
          },
        },
        required: ['organization_key', 'space_key'],
      },
      traits: {},
    },
    title: 'entry_publish',
  };
  const message = {
    event: 'entry_publish',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('entry_publish', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema of entry references
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function entryReferences(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema of entry references',
    properties: {
      context: {},
      properties: {
        properties: {
          circular_references_count: {
            type: 'number',
          },
          entry_id: {
            type: 'string',
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: 'string',
          },
          references_depth: {
            type: 'number',
          },
          references_per_level: {
            type: ['number'],
          },
          space_key: {
            type: 'string',
          },
        },
        required: ['organization_key', 'space_key', 'entry_id'],
      },
      traits: {},
    },
    title: 'entry_references',
  };
  const message = {
    event: 'entry_references',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('entry_references', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'entry_references:dialog_open' track call.
 *
 * @param {EntryReferencesDialogOpen} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function entryReferencesDialogOpen(
  props?: EntryReferencesDialogOpen,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  circular_references_count: {
                    type: ['integer'],
                  },
                  entity_id: {
                    type: ['string'],
                  },
                  references_depth: {
                    type: ['integer'],
                  },
                  references_per_level: {
                    items: {
                      type: 'integer',
                    },
                    type: 'array',
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'entry_references:dialog_open',
    type: 'object',
  };
  const message = {
    event: 'entry_references:dialog_open',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('entry_references:dialog_open', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'entry_references:publish' track call.
 *
 * @param {EntryReferencesPublish} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function entryReferencesPublish(
  props?: EntryReferencesPublish,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  entity_id: {
                    type: ['string'],
                  },
                  references_count: {
                    type: ['integer'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'entry_references:publish',
    type: 'object',
  };
  const message = {
    event: 'entry_references:publish',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('entry_references:publish', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'entry_references:validate' track call.
 *
 * @param {EntryReferencesValidate} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function entryReferencesValidate(
  props?: EntryReferencesValidate,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  entity_id: {
                    type: ['string'],
                  },
                  references_count: {
                    type: ['integer'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'entry_references:validate',
    type: 'object',
  };
  const message = {
    event: 'entry_references:validate',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('entry_references:validate', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema for tracking entry page views
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function entryView(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema for tracking entry page views',
    properties: {
      context: {},
      properties: {
        properties: {
          content_type_id: {
            type: ['string'],
          },
          content_type_name: {
            type: ['string'],
          },
          contexts: {
            type: ['string'],
          },
          editor_type: {
            enum: ['bulk_editor', 'slide_in_editor', 'entry_editor'],
            type: 'string',
          },
          entry_id: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          slide_in_level: {
            type: 'integer',
          },
          space_key: {
            type: ['string'],
          },
        },
        required: [
          'contexts',
          'organization_key',
          'space_key',
          'entry_id',
          'content_type_id',
          'content_type_name',
          'editor_type',
        ],
      },
      traits: {},
    },
    title: 'entry_view',
  };
  const message = {
    event: 'entry_view',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('entry_view', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Environment aliases tracking
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function environmentAliases(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Environment aliases tracking',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            description: 'refers to the action performed',
            type: ['string', 'null'],
          },
          environment_alias_id: {
            description: 'refers to the internal id of the environment alias',
            type: ['integer'],
          },
          environment_alias_key: {
            description: 'refers to the key of the environment alias',
            type: ['string', 'null'],
          },
          environment_key: {
            type: ['string'],
          },
          from_environment_id: {
            description: 'refers to the key of the previously aliased environment',
            type: ['string', 'null'],
          },
          from_environment_uuid: {
            description: 'refers to the UUID of the previously aliased environment',
            type: ['string', 'null'],
          },
          inferred_intent: {
            description:
              'This field will contain the X-Contentful-Header sent by sdks and the webapp, allowing us to track the intent of the creation.',
            type: ['string', 'null'],
          },
          organization_key: {
            description: 'refers to organization key',
            type: ['string', 'null'],
          },
          platform: {
            description:
              'this will be `web-app` if the webapp sent the request, or anything else the x-contentful-header contains in the platform field, if existing. Null otherwise.',
            type: ['string', 'null'],
          },
          space_key: {
            description: 'refers to space key',
            type: ['string'],
          },
          to_environment_id: {
            description: 'refers to the key of the newly aliased environment',
            type: ['string', 'null'],
          },
          to_environment_uuid: {
            description: 'refers to the UUID of the newly aliased environment',
            type: ['string', 'null'],
          },
          user_agent: {
            description: 'refers to the http user agent header sent',
            type: ['string', 'null'],
          },
        },
        required: [
          'organization_key',
          'space_key',
          'action',
          'environment_alias_id',
          'environment_alias_key',
          'to_environment_id',
        ],
      },
      traits: {},
    },
    title: 'environment_aliases',
  };
  const message = {
    event: 'environment_aliases',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('environment_aliases', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Environment branching tracking
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function environmentBranching(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Environment branching tracking',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string', 'null'],
          },
          count_assets: {
            description: 'refers to number of assets in the source environment',
            type: ['integer', 'null'],
          },
          count_content_types: {
            description: 'refers to number of content types in the source environment',
            type: ['integer', 'null'],
          },
          count_entries: {
            description: 'refers to number of entries in the source environment',
            type: ['integer', 'null'],
          },
          count_locales: {
            description: 'refers to number of locales in the source environment',
            type: ['integer', 'null'],
          },
          environment_key: {
            type: ['string'],
          },
          environment_uuid: {
            type: ['string', 'null'],
          },
          inferred_intent: {
            description:
              'This field will contain the X-Contentful-Header send by sdks and the webapp, allowing us to track the intent of the creation.',
            type: ['string', 'null'],
          },
          organization_key: {
            description: 'refers to organization key',
            type: ['string', 'null'],
          },
          platform: {
            description:
              'this will be `web-app` if the webapp sent the request, or anything else the x-contentful-header contains in the platform field, if existing. Null otherwise.',
            type: ['string', 'null'],
          },
          source_environment_id: {
            description: 'refers to environment key',
            type: ['string', 'null'],
          },
          source_environment_uuid: {
            type: ['string', 'null'],
          },
          space_key: {
            description: 'refers to space key',
            type: ['string'],
          },
          user_agent: {
            description: 'refers to the http user agent header sent',
            type: ['string', 'null'],
          },
        },
        required: ['organization_key', 'space_key', 'action'],
      },
      traits: {},
    },
    title: 'environment_branching',
  };
  const message = {
    event: 'environment_branching',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('environment_branching', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema for A/B tests, inside of the user_interface
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function experiment(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema for A/B tests, inside of the user_interface',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          experiment_id: {
            type: ['string'],
          },
          interaction_context: {
            type: ['string', 'null'],
          },
          organization_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          variation: {
            type: ['boolean', 'null'],
          },
        },
        required: ['experiment_id', 'variation', 'action'],
      },
      traits: {},
    },
    title: 'experiment',
  };
  const message = {
    event: 'experiment',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('experiment', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Allows to track which user is part of a UI experiment or a particular A/B test variation, e.g. controlled through `LaunchDarkly` or another kind of feature flag.
 *
 * @param {ExperimentStarted} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function experimentStarted(
  props: ExperimentStarted,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description:
      'Allows to track which user is part of a UI experiment or a particular A/B test variation, e.g. controlled through `LaunchDarkly` or another kind of feature flag.',
    labels: {},
    properties: {
      context: {},
      properties: {
        properties: {
          environment_key: {
            type: ['string'],
          },
          experiment_id: {
            description: 'The experiment name the current user is part of',
            type: 'string',
          },
          experiment_variation: {
            description: 'The experiment variation the current user is assigned to',
            type: 'string',
          },
          organization_key: {
            description: 'Current organization key',
            type: 'string',
          },
          space_key: {
            description: 'Current space key',
            type: 'string',
          },
        },
        required: ['experiment_id', 'experiment_variation'],
        type: 'object',
      },
      traits: {
        type: 'object',
      },
    },
    required: ['properties'],
    title: 'experiment_started',
    type: 'object',
  };
  const message = {
    event: 'experiment_started',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('experiment_started', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Extension was activated
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function extensionActivate(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Extension was activated',
    properties: {
      context: {},
      properties: {
        properties: {
          environment_key: {
            type: ['string'],
          },
          extension_definition_id: {
            description: 'Extenstion Indentifyer',
            type: ['string', 'null'],
          },
          extension_id: {
            description: 'Extenstion Indentifyer',
            type: 'string',
          },
          location: {
            description: 'Dunno',
            type: 'string',
          },
          organization_key: {
            description: 'Refers to organization_key',
            type: ['string', 'null'],
          },
          space_key: {
            description: 'Refers to space_key',
            type: 'string',
          },
        },
        required: ['space_key', 'extension_id', 'location'],
      },
      traits: {},
    },
    title: 'extension_activate',
  };
  const message = {
    event: 'extension_activate',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('extension_activate', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Extension rendered
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function extensionRender(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Extension rendered',
    properties: {
      context: {},
      properties: {
        properties: {
          contexts: {
            type: ['string'],
          },
          environment_key: {
            description: 'Refers to environment_key',
            type: 'string',
          },
          extension_definition_id: {
            type: ['string', 'null'],
          },
          extension_id: {
            type: 'string',
          },
          extension_name: {
            type: 'string',
          },
          installation_params: {
            type: 'array',
          },
          instance_params: {
            type: 'array',
          },
          location: {
            type: 'string',
          },
          src: {
            type: ['string', 'null'],
          },
        },
        required: [
          'contexts',
          'location',
          'extension_id',
          'extension_name',
          'src',
          'installation_params',
          'instance_params',
        ],
      },
      traits: {},
    },
    title: 'extension_render',
  };
  const message = {
    event: 'extension_render',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('extension_render', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Extension set a value of a field
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function extensionSetValue(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Extension set a value of a field',
    properties: {
      context: {},
      properties: {
        properties: {
          content_type_id: {
            type: 'string',
          },
          entry_id: {
            type: 'string',
          },
          environment_key: {
            type: ['string'],
          },
          extension_definition_id: {
            type: ['string', 'null'],
          },
          extension_id: {
            type: 'string',
          },
          field_id: {
            type: 'string',
          },
          locale_code: {
            type: 'string',
          },
          organization_key: {
            description: 'Refers to organization_key',
            type: ['string', 'null'],
          },
          space_key: {
            description: 'Refers to space_key',
            type: 'string',
          },
        },
        required: [
          'space_key',
          'entry_id',
          'content_type_id',
          'field_id',
          'locale_code',
          'extension_id',
        ],
      },
      traits: {},
    },
    title: 'extension_set_value',
  };
  const message = {
    event: 'extension_set_value',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('extension_set_value', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Bulk references editor feature tracking
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function featureBulkEditor(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Bulk references editor feature tracking',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          content_type_id: {
            type: ['string', 'null'],
          },
          entry_id: {
            type: ['string', 'null'],
          },
          environment_key: {
            type: ['string'],
          },
          num_edited_entries: {
            type: ['integer', 'null'],
          },
          num_published_entries: {
            type: ['integer', 'null'],
          },
          option_added: {
            type: ['boolean', 'null'],
          },
          option_existing: {
            type: ['boolean', 'null'],
          },
          organization_key: {
            type: ['string', 'null'],
          },
          parent_entry_id: {
            type: ['string', 'null'],
          },
          ref_count: {
            type: ['integer', 'null'],
          },
          space_key: {
            type: ['string'],
          },
          status: {
            type: ['string', 'null'],
          },
        },
        required: ['space_key', 'action'],
      },
      traits: {},
    },
    title: 'feature_bulk_editor',
  };
  const message = {
    event: 'feature_bulk_editor',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('feature_bulk_editor', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Events for the comments endpoint, emitted on CUD actions. Note: The Tasks feature is using the comments endpoint behind the scenes.
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function featureCommentsAndTasks(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description:
      'Events for the comments endpoint, emitted on CUD actions. Note: The Tasks feature is using the comments endpoint behind the scenes.',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            description: 'The action that is performed on the comment or task',
            type: ['string'],
          },
          comment_id: {
            description: "The comment's (or tasks) ID",
            type: ['string'],
          },
          comment_type: {
            description:
              'The kind of comment that this event is about (can be a Task or normal Comment)',
            type: ['string'],
          },
          entity_id: {
            description: 'The ID of the entity containing the comment',
            type: ['string'],
          },
          entity_type: {
            description: 'The type of the entity containing the comment',
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          environment_uuid: {
            description: 'Environment internally used ID',
            type: ['string'],
          },
          has_body_changed: {
            description:
              "Whether the comment's message or task's title was touched by the performed action. Only relevant for `update` action (omitted otherwise)",
            type: ['boolean', 'null'],
          },
          new_assignee_id: {
            description:
              'ID of the assigned user after the action. Skip in case of `delete` action action and for non-task comments.',
            type: ['string', 'null'],
          },
          new_body_length: {
            description:
              "Total length of the comment's message or task's title after the action. Skip in case of a `delete` action.",
            type: ['integer', 'null'],
          },
          new_status: {
            description:
              'Status ("resolved" or "open") of a task after the action. Skip in case of a `delete` action and for non-task comments.',
            type: ['string', 'null'],
          },
          old_assignee_id: {
            description:
              'ID of the assigned user before the action. Skip in case of a `create` action and for non-task comments.',
            type: ['string', 'null'],
          },
          old_body_length: {
            description:
              "Total length of the comment's message or task's title before the action. Skip in case of a `create` action.",
            type: ['integer', 'null'],
          },
          old_status: {
            description:
              'Status ("resolved" or "open") of a task before the action. Skip in case of a `create` action and for non-task comments.',
            type: ['string', 'null'],
          },
          organization_key: {
            description: 'Gatekeeper organization key',
            type: ['string'],
          },
          parent_comment_id: {
            description:
              'ID of the parent comment (discussion thread), `null` if the comment has no parent (and therefore is a parent itself)',
            type: ['string', 'null'],
          },
          space_key: {
            description: 'Gatekeeper space key',
            type: ['string'],
          },
        },
        required: [
          'organization_key',
          'space_key',
          'environment_key',
          'environment_uuid',
          'entity_id',
          'entity_type',
          'action',
          'comment_type',
          'comment_id',
        ],
      },
      traits: {},
    },
    title: 'feature_comments_and_tasks',
  };
  const message = {
    event: 'feature_comments_and_tasks',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('feature_comments_and_tasks', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Generated empty schema for feature_playground
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function featurePlayground(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Generated empty schema for feature_playground',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          integration_environment: {
            type: ['string', 'null'],
          },
          mocked_device: {
            type: ['string', 'null'],
          },
          organization_key: {
            type: ['string', 'null'],
          },
        },
        required: ['action'],
      },
      traits: {},
    },
    title: 'feature_playground',
  };
  const message = {
    event: 'feature_playground',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('feature_playground', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema of interacting with a reference entry
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function featureReferenceAction(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema of interacting with a reference entry',
    properties: {
      context: {},
      properties: {
        properties: {
          content_type_id: {
            type: 'string',
          },
          environment_key: {
            type: ['string'],
          },
          event_type: {
            type: 'string',
          },
          organization_key: {
            type: 'string',
          },
          parent_entry_id: {
            type: 'string',
          },
          space_key: {
            type: 'string',
          },
        },
        required: [
          'organization_key',
          'space_key',
          'content_type_id',
          'event_type',
          'parent_entry_id',
        ],
      },
      traits: {},
    },
    title: 'feature_reference_action',
  };
  const message = {
    event: 'feature_reference_action',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('feature_reference_action', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Snapshot tracking feature
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function featureSnapshot(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Snapshot tracking feature',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          entry_fields_count: {
            type: ['integer', 'null'],
          },
          entry_id: {
            type: ['string'],
          },
          entry_version: {
            type: ['integer', 'null'],
          },
          environment_key: {
            type: ['string'],
          },
          option_changes_discarded: {
            type: ['boolean', 'null'],
          },
          option_full_restore: {
            type: ['boolean', 'null'],
          },
          option_show_diffs_only: {
            type: ['boolean', 'null'],
          },
          organization_key: {
            type: ['string', 'null'],
          },
          restore_fields_count: {
            type: ['integer', 'null'],
          },
          snapshot_id: {
            type: ['string', 'null'],
          },
          snapshot_version: {
            type: ['integer', 'null'],
          },
          source: {
            type: ['string', 'null'],
          },
          space_key: {
            type: ['string'],
          },
        },
        required: ['space_key', 'entry_id', 'action'],
      },
      traits: {},
    },
    title: 'feature_snapshot',
  };
  const message = {
    event: 'feature_snapshot',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('feature_snapshot', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Action tracking for Single Sign-On (SSO) Self Configuration via the webapp
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function featureSsoSelfConfiguration(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Action tracking for Single Sign-On (SSO) Self Configuration via the webapp',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            description: 'The action being performed',
            type: 'string',
          },
          connection_test_result_errors: {
            description:
              'If the action is `connection_test_result`, the errors that occurred if the status is failure',
            type: ['array', 'null'],
          },
          connection_test_result_status: {
            description:
              'If the action is `connection_test_result`, the status of the latest test result',
            type: ['string', 'null'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            description: 'The organization that this is happening in',
            type: ['string', 'null'],
          },
        },
        required: ['organization_key', 'action'],
      },
      traits: {},
    },
    title: 'feature_sso_self_configuration',
  };
  const message = {
    event: 'feature_sso_self_configuration',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track(
      'feature_sso_self_configuration',
      props || {},
      withTypewriterContext(options),
      callback
    );
  }
}
/**
 * Generic event for tracking text editor widgets (e.g. StructuredText or Markdown).
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function featureTextEditor(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description:
      'Generic event for tracking text editor widgets (e.g. StructuredText or Markdown).',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            description: 'The action the user has triggered within the text editor',
            type: ['string'],
          },
          action_origin: {
            description:
              "Where the action was triggered, e.g. toolbar icon or shortcut (`null` means we don't know)",
            type: ['string', 'null'],
          },
          additional_data: {
            description: 'Allows to add additional action specific data',
            type: ['object', 'null'],
          },
          character_count_after: {
            description: 'Character count after the action was applied',
            type: ['integer', 'null'],
          },
          character_count_before: {
            description: 'Character count before the action was applied (useful for paste action)',
            type: ['integer', 'null'],
          },
          character_count_selection: {
            description:
              'The number of characters selected when the action was triggered (e.g. useful to know whether a hyperlink is mostly applied to a selection or not)',
            type: ['integer', 'null'],
          },
          content_type_id: {
            description: 'content_api content_type ID of the entry with the text editor',
            type: ['string'],
          },
          editor_name: {
            description: 'The editor widget name (use front-end widget ID)',
            type: 'string',
          },
          entry_id: {
            description: 'content_api entry ID with the text editor widget',
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          field_id: {
            description: 'ID of field with the text editor widget',
            type: ['string'],
          },
          field_locale: {
            description:
              'Locale ID complementing the `field_id`, null if the action is not for one particular locale only.',
            type: ['string', 'null'],
          },
          is_fullscreen: {
            description: 'Whether the action was triggered while full-screen mode was active',
            type: ['boolean'],
          },
          organization_key: {
            description: 'Gatekeeper organization KEY',
            type: ['string'],
          },
          space_key: {
            description: 'Gatekeeper space KEY',
            type: ['string'],
          },
        },
        required: [
          'organization_key',
          'space_key',
          'content_type_id',
          'entry_id',
          'field_id',
          'field_locale',
          'editor_name',
          'action',
          'is_fullscreen',
        ],
      },
      traits: {},
    },
    title: 'feature_text_editor',
  };
  const message = {
    event: 'feature_text_editor',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('feature_text_editor', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'global:app_loaded' track call.
 *
 * @param {GlobalAppLoaded} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function globalAppLoaded(
  props?: GlobalAppLoaded,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          contexts: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'global:app_loaded',
    type: 'object',
  };
  const message = {
    event: 'global:app_loaded',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('global:app_loaded', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'global:dialog' track call.
 *
 * @param {GlobalDialog} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function globalDialog(
  props?: GlobalDialog,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              name: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              purpose: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
          schema: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'global:dialog',
    type: 'object',
  };
  const message = {
    event: 'global:dialog',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('global:dialog', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'global:space_changed' track call.
 *
 * @param {GlobalSpaceChanged} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function globalSpaceChanged(
  props?: GlobalSpaceChanged,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          payload: {
            type: ['object'],
          },
          scope: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'global:space_changed',
    type: 'object',
  };
  const message = {
    event: 'global:space_changed',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('global:space_changed', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'global:space_left' track call.
 *
 * @param {GlobalSpaceLeft} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function globalSpaceLeft(
  props?: GlobalSpaceLeft,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          payload: {
            type: ['object'],
          },
          scope: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'global:space_left',
    type: 'object',
  };
  const message = {
    event: 'global:space_left',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('global:space_left', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'global:state_changed' track call.
 *
 * @param {GlobalStateChanged} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function globalStateChanged(
  props?: GlobalStateChanged,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              from_state: {
                type: ['string'],
              },
              from_state_params: {
                properties: {
                  accepted_permissions: {},
                  add_to_context: {
                    type: ['boolean'],
                  },
                  api_key_id: {
                    type: ['string'],
                  },
                  app_id: {},
                  asset_id: {
                    type: ['string'],
                  },
                  content_type_id: {
                    type: ['string'],
                  },
                  definition_id: {
                    type: ['string'],
                  },
                  entry_id: {
                    type: ['string'],
                  },
                  environment_key: {
                    type: ['string'],
                  },
                  ignore_leave_confirmation: {
                    type: ['boolean'],
                  },
                  invitation_id: {
                    type: ['string'],
                  },
                  jump_to_role: {
                    type: ['string'],
                  },
                  locale_id: {
                    type: ['string'],
                  },
                  org_id: {},
                  org_owner_or_admin: {},
                  path_suffix: {
                    type: ['string'],
                  },
                  referrer: {},
                  space_key: {
                    type: ['string'],
                  },
                  tab: {
                    type: ['string'],
                  },
                  template_id: {},
                  user_id: {
                    type: ['string'],
                  },
                  webhook_id: {
                    type: ['string'],
                  },
                },
                type: 'object',
              },
              organization_key: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
              to_state: {
                type: ['string'],
              },
              to_state_params: {
                properties: {
                  accepted_permissions: {},
                  add_to_context: {
                    type: ['boolean'],
                  },
                  api_key_id: {
                    type: ['string'],
                  },
                  app_id: {},
                  asset_id: {
                    type: ['string'],
                  },
                  content_type_id: {
                    type: ['string'],
                  },
                  definition_id: {
                    type: ['string'],
                  },
                  entry_id: {
                    type: ['string'],
                  },
                  environment_key: {
                    type: ['string'],
                  },
                  ignore_leave_confirmation: {
                    type: ['boolean'],
                  },
                  jump_to_role: {
                    type: ['string'],
                  },
                  locale_id: {
                    type: ['string'],
                  },
                  org_id: {
                    type: ['string'],
                  },
                  org_owner_or_admin: {},
                  path_suffix: {
                    type: ['string'],
                  },
                  referrer: {},
                  space_key: {
                    type: ['string'],
                  },
                  tab: {
                    type: ['string'],
                  },
                  template_id: {},
                  user_id: {
                    type: ['string'],
                  },
                  webhook_id: {
                    type: ['string'],
                  },
                },
                type: 'object',
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'global:state_changed',
    type: 'object',
  };
  const message = {
    event: 'global:state_changed',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('global:state_changed', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'incoming_links:dialog_confirm' track call.
 *
 * @param {IncomingLinksDialogConfirm} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function incomingLinksDialogConfirm(
  props?: IncomingLinksDialogConfirm,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  dialog_action: {
                    type: ['string'],
                  },
                  dialog_session_id: {
                    type: ['string'],
                  },
                  entity_id: {
                    type: ['string'],
                  },
                  entity_type: {
                    type: ['string'],
                  },
                  incoming_links_count: {
                    type: ['integer'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'incoming_links:dialog_confirm',
    type: 'object',
  };
  const message = {
    event: 'incoming_links:dialog_confirm',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('incoming_links:dialog_confirm', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'incoming_links:dialog_open' track call.
 *
 * @param {IncomingLinksDialogOpen} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function incomingLinksDialogOpen(
  props?: IncomingLinksDialogOpen,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  dialog_action: {
                    type: ['string'],
                  },
                  dialog_session_id: {
                    type: ['string'],
                  },
                  entity_id: {
                    type: ['string'],
                  },
                  entity_type: {
                    type: ['string'],
                  },
                  incoming_links_count: {
                    type: ['integer'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'incoming_links:dialog_open',
    type: 'object',
  };
  const message = {
    event: 'incoming_links:dialog_open',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('incoming_links:dialog_open', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'incoming_links:query' track call.
 *
 * @param {IncomingLinksQuery} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function incomingLinksQuery(
  props?: IncomingLinksQuery,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  entity_id: {
                    type: ['string'],
                  },
                  entity_type: {
                    type: ['string'],
                  },
                  incoming_link_ids: {
                    items: {
                      type: 'string',
                    },
                    type: 'array',
                  },
                  incoming_links_count: {
                    type: ['integer'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'incoming_links:query',
    type: 'object',
  };
  const message = {
    event: 'incoming_links:query',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('incoming_links:query', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Emitted when the user cancels the job
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function jobsCancel(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Emitted when the user cancels the job',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          job_id: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
        },
        required: ['organization_key', 'space_key', 'job_id', 'action'],
      },
      traits: {},
    },
    title: 'jobs_cancel',
  };
  const message = {
    event: 'jobs_cancel',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('jobs_cancel', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Emitted when a user creates a job
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function jobsCreate(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Emitted when a user creates a job',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          job_id: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          scheduled_for: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          timezone_offset: {
            type: ['integer'],
          },
        },
        required: [
          'organization_key',
          'space_key',
          'action',
          'job_id',
          'scheduled_for',
          'timezone_offset',
        ],
      },
      traits: {},
    },
    title: 'jobs_create',
  };
  const message = {
    event: 'jobs_create',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('jobs_create', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Emitted when a job is triggered
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function jobsProcessing(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Emitted when a job is triggered',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          job_id: {
            type: ['string'],
          },
          status_code: {
            description: 'code of the status of the current job process. Example: 200 for success',
            type: ['integer'],
          },
        },
        required: ['job_id', 'action', 'status_code'],
      },
      traits: {},
    },
    title: 'jobs_processing',
  };
  const message = {
    event: 'jobs_processing',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('jobs_processing', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema for tracking every state transition in the user interface
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function pageView(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema for tracking every state transition in the user interface',
    properties: {
      context: {},
      properties: {
        properties: {
          environment_key: {
            type: ['string'],
          },
          from_state: {
            type: ['string'],
          },
          from_state_params: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          to_state: {
            type: ['string'],
          },
          to_state_params: {
            type: ['string'],
          },
        },
        required: ['to_state'],
      },
      traits: {},
    },
    title: 'page_view',
  };
  const message = {
    event: 'page_view',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('page_view', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'perf:dom_content_loaded' track call.
 *
 * @param {PerfDomContentLoaded} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function perfDomContentLoaded(
  props?: PerfDomContentLoaded,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  state_name: {
                    type: ['string'],
                  },
                  value: {
                    type: ['number'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'perf:dom_content_loaded',
    type: 'object',
  };
  const message = {
    event: 'perf:dom_content_loaded',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('perf:dom_content_loaded', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'perf:first_contentful_paint' track call.
 *
 * @param {PerfFirstContentfulPaint} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function perfFirstContentfulPaint(
  props?: PerfFirstContentfulPaint,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  state_name: {
                    type: ['string'],
                  },
                  value: {
                    type: ['number'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'perf:first_contentful_paint',
    type: 'object',
  };
  const message = {
    event: 'perf:first_contentful_paint',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('perf:first_contentful_paint', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'perf:time_to_interactive' track call.
 *
 * @param {PerfTimeToInteractive} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function perfTimeToInteractive(
  props?: PerfTimeToInteractive,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  state_name: {
                    type: ['string'],
                  },
                  value: {
                    type: ['number'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'perf:time_to_interactive',
    type: 'object',
  };
  const message = {
    event: 'perf:time_to_interactive',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('perf:time_to_interactive', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'personal_access_token:action' track call.
 *
 * @param {PersonalAccessTokenAction} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function personalAccessTokenAction(
  props?: PersonalAccessTokenAction,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              personal_access_token_id: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'personal_access_token:action',
    type: 'object',
  };
  const message = {
    event: 'personal_access_token:action',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('personal_access_token:action', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * PrevieApiKey schema
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function previewApiKey(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'PrevieApiKey schema',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string', 'null'],
          },
          space_key: {
            type: ['string'],
          },
          version: {
            type: ['integer', 'null'],
          },
        },
        required: ['space_key', 'action'],
      },
      traits: {},
    },
    title: 'preview_api_key',
  };
  const message = {
    event: 'preview_api_key',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('preview_api_key', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'release_created' track call.
 *
 * @param {ReleaseCreated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function releaseCreated(
  props: ReleaseCreated,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    labels: {},
    properties: {
      context: {},
      properties: {
        properties: {
          environment_key: {
            description: '',
            type: 'string',
          },
          organization_key: {
            description: '',
            type: 'string',
          },
          release_id: {
            description: '',
            type: 'string',
          },
          space_key: {
            description: '',
            type: 'string',
          },
        },
        required: ['environment_key', 'organization_key', 'release_id', 'space_key'],
        type: 'object',
      },
      traits: {
        type: 'object',
      },
    },
    required: ['properties'],
    title: 'release_created',
    type: 'object',
  };
  const message = {
    event: 'release_created',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('release_created', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'release_dialog_box' track call.
 *
 * @param {ReleaseDialogBox} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function releaseDialogBox(
  props: ReleaseDialogBox,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    labels: {},
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            description: '',
            pattern: 'open|close',
            type: 'string',
          },
          environment_key: {
            description: '',
            type: 'string',
          },
          organization_key: {
            description: '',
            type: 'string',
          },
          purpose: {
            description: '',
            pattern: 'submit|create|cancel',
            type: 'string',
          },
          space_key: {
            description: '',
            type: 'string',
          },
        },
        required: ['action', 'environment_key', 'organization_key', 'purpose', 'space_key'],
        type: 'object',
      },
      traits: {
        type: 'object',
      },
    },
    required: ['properties'],
    title: 'release_dialog_box',
    type: 'object',
  };
  const message = {
    event: 'release_dialog_box',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('release_dialog_box', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'release_entity_added' track call.
 *
 * @param {ReleaseEntityAdded} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function releaseEntityAdded(
  props: ReleaseEntityAdded,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    labels: {},
    properties: {
      context: {},
      properties: {
        properties: {
          asset_count: {
            description: '',
            type: 'integer',
          },
          entry_count: {
            description: '',
            type: 'integer',
          },
          environment_key: {
            description: '',
            type: 'string',
          },
          organization_key: {
            description: '',
            type: 'string',
          },
          release_id: {
            description: '',
            type: 'string',
          },
          space_key: {
            description: '',
            type: 'string',
          },
        },
        required: [
          'asset_count',
          'entry_count',
          'environment_key',
          'organization_key',
          'release_id',
          'space_key',
        ],
        type: 'object',
      },
      traits: {
        type: 'object',
      },
    },
    required: ['properties'],
    title: 'release_entity_added',
    type: 'object',
  };
  const message = {
    event: 'release_entity_added',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('release_entity_added', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'release_entity_removed' track call.
 *
 * @param {ReleaseEntityRemoved} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function releaseEntityRemoved(
  props: ReleaseEntityRemoved,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    labels: {},
    properties: {
      context: {},
      properties: {
        properties: {
          entity_id: {
            description: '',
            type: 'string',
          },
          entity_type: {
            description: '',
            pattern: 'Entry|Asset',
            type: 'string',
          },
          environment_key: {
            description: '',
            type: 'string',
          },
          organization_key: {
            description: '',
            type: 'string',
          },
          release_id: {
            description: '',
            type: 'string',
          },
          space_key: {
            description: '',
            type: 'string',
          },
        },
        required: [
          'entity_id',
          'entity_type',
          'environment_key',
          'organization_key',
          'release_id',
          'space_key',
        ],
        type: 'object',
      },
      traits: {
        type: 'object',
      },
    },
    required: ['properties'],
    title: 'release_entity_removed',
    type: 'object',
  };
  const message = {
    event: 'release_entity_removed',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('release_entity_removed', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'release_published' track call.
 *
 * @param {ReleasePublished} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function releasePublished(
  props: ReleasePublished,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    labels: {},
    properties: {
      context: {},
      properties: {
        properties: {
          asset_count: {
            description: '',
            type: 'integer',
          },
          entry_count: {
            description: '',
            type: 'integer',
          },
          environment_key: {
            description: '',
            type: 'string',
          },
          organization_key: {
            description: '',
            type: 'string',
          },
          release_id: {
            description: '',
            type: 'string',
          },
          space_key: {
            description: '',
            type: 'string',
          },
        },
        required: [
          'asset_count',
          'entry_count',
          'environment_key',
          'organization_key',
          'release_id',
          'space_key',
        ],
        type: 'object',
      },
      traits: {
        type: 'object',
      },
    },
    required: ['properties'],
    title: 'release_published',
    type: 'object',
  };
  const message = {
    event: 'release_published',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('release_published', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'release_schedule_canceled' track call.
 *
 * @param {ReleaseScheduleCanceled} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function releaseScheduleCanceled(
  props: ReleaseScheduleCanceled,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    labels: {},
    properties: {
      context: {},
      properties: {
        properties: {
          environment_key: {
            description: '',
            type: 'string',
          },
          job_id: {
            description: '',
            type: 'string',
          },
          organization_key: {
            description: '',
            type: 'string',
          },
          release_id: {
            description: '',
            type: 'string',
          },
          space_key: {
            description: '',
            type: 'string',
          },
        },
        required: ['environment_key', 'job_id', 'organization_key', 'release_id', 'space_key'],
        type: 'object',
      },
      traits: {
        type: 'object',
      },
    },
    required: ['properties'],
    title: 'release_schedule_canceled',
    type: 'object',
  };
  const message = {
    event: 'release_schedule_canceled',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('release_schedule_canceled', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'release_schedule_created' track call.
 *
 * @param {ReleaseScheduleCreated} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function releaseScheduleCreated(
  props: ReleaseScheduleCreated,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    labels: {},
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            description: '',
            pattern: 'publish|unpublish',
            type: 'string',
          },
          asset_count: {
            description: '',
            type: 'integer',
          },
          entry_count: {
            description: '',
            type: 'integer',
          },
          environment_key: {
            description: '',
            type: 'string',
          },
          job_id: {
            description: '',
            type: 'string',
          },
          organization_key: {
            description: '',
            type: 'string',
          },
          release_id: {
            description: '',
            type: 'string',
          },
          scheduled_for: {
            description: '',
            type: 'integer',
          },
          space_key: {
            description: '',
            type: 'string',
          },
        },
        required: [
          'action',
          'asset_count',
          'entry_count',
          'environment_key',
          'job_id',
          'organization_key',
          'release_id',
          'scheduled_for',
          'space_key',
        ],
        type: 'object',
      },
      traits: {
        type: 'object',
      },
    },
    required: ['properties'],
    title: 'release_schedule_created',
    type: 'object',
  };
  const message = {
    event: 'release_schedule_created',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('release_schedule_created', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'release_trashed' track call.
 *
 * @param {ReleaseTrashed} props - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function releaseTrashed(
  props: ReleaseTrashed,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    labels: {},
    properties: {
      context: {},
      properties: {
        properties: {
          environment_key: {
            description: '',
            type: 'string',
          },
          organization_key: {
            description: '',
            type: 'string',
          },
          release_id: {
            description: '',
            type: 'string',
          },
          space_key: {
            description: '',
            type: 'string',
          },
        },
        required: ['environment_key', 'organization_key', 'release_id', 'space_key'],
        type: 'object',
      },
      traits: {
        type: 'object',
      },
    },
    required: ['properties'],
    title: 'release_trashed',
    type: 'object',
  };
  const message = {
    event: 'release_trashed',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('release_trashed', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'search:entry_clicked' track call.
 *
 * @param {SearchEntryClicked} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function searchEntryClicked(
  props?: SearchEntryClicked,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          entity_type: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          index: {
            type: ['integer'],
          },
          organization_key: {
            type: ['string'],
          },
          result_count: {
            type: ['integer'],
          },
          search_filters: {
            items: {
              type: 'string',
            },
            type: 'array',
          },
          search_query: {
            type: ['string'],
          },
          sequence_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'search:entry_clicked',
    type: 'object',
  };
  const message = {
    event: 'search:entry_clicked',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('search:entry_clicked', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'search:filter_added' track call.
 *
 * @param {SearchFilterAdded} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function searchFilterAdded(
  props?: SearchFilterAdded,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          entity_type: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          filter: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          result_count: {
            type: ['integer'],
          },
          search_filters: {
            items: {
              type: 'string',
            },
            type: 'array',
          },
          search_query: {
            type: ['string'],
          },
          sequence_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'search:filter_added',
    type: 'object',
  };
  const message = {
    event: 'search:filter_added',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('search:filter_added', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'search:filter_removed' track call.
 *
 * @param {SearchFilterRemoved} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function searchFilterRemoved(
  props?: SearchFilterRemoved,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          entity_type: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          filter: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          result_count: {
            type: ['integer'],
          },
          search_filters: {
            items: {
              type: 'string',
            },
            type: 'array',
          },
          search_query: {
            type: ['string'],
          },
          sequence_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'search:filter_removed',
    type: 'object',
  };
  const message = {
    event: 'search:filter_removed',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('search:filter_removed', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'search:query_changed' track call.
 *
 * @param {SearchQueryChanged} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function searchQueryChanged(
  props?: SearchQueryChanged,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          entity_type: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          result_count: {
            type: ['integer'],
          },
          search_filters: {
            items: {
              type: 'string',
            },
            type: 'array',
          },
          search_query: {
            type: ['string'],
          },
          sequence_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'search:query_changed',
    type: 'object',
  };
  const message = {
    event: 'search:query_changed',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('search:query_changed', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'search:search_performed' track call.
 *
 * @param {SearchSearchPerformed} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function searchSearchPerformed(
  props?: SearchSearchPerformed,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          content_type_id: {},
          entity_type: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          result_count: {
            type: ['integer'],
          },
          search_filters: {
            items: {
              type: 'string',
            },
            type: 'array',
          },
          search_query: {
            type: ['string'],
          },
          sequence_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'search:search_performed',
    type: 'object',
  };
  const message = {
    event: 'search:search_performed',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('search:search_performed', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'search:view_created' track call.
 *
 * @param {SearchViewCreated} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function searchViewCreated(
  props?: SearchViewCreated,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          content_type_id: {},
          entity_type: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          folder_id: {
            type: ['string'],
          },
          folder_title: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          search_filters: {
            items: {
              type: 'string',
            },
            type: 'array',
          },
          search_query: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          view_id: {
            type: ['string'],
          },
          view_type: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'search:view_created',
    type: 'object',
  };
  const message = {
    event: 'search:view_created',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('search:view_created', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'search:view_deleted' track call.
 *
 * @param {SearchViewDeleted} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function searchViewDeleted(
  props?: SearchViewDeleted,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          entity_type: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          view_id: {
            type: ['string'],
          },
          view_type: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'search:view_deleted',
    type: 'object',
  };
  const message = {
    event: 'search:view_deleted',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('search:view_deleted', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'search:view_loaded' track call.
 *
 * @param {SearchViewLoaded} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function searchViewLoaded(
  props?: SearchViewLoaded,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          content_type_id: {},
          entity_type: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          result_count: {
            type: ['integer'],
          },
          search_filters: {
            items: {
              type: 'string',
            },
            type: 'array',
          },
          search_query: {
            type: ['string'],
          },
          sequence_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          view_id: {
            type: ['string'],
          },
          view_roles: {},
          view_title: {
            type: ['string'],
          },
          view_type: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'search:view_loaded',
    type: 'object',
  };
  const message = {
    event: 'search:view_loaded',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('search:view_loaded', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema for a search performed in the top bar of the webapp
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function searchPerform(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema for a search performed in the top bar of the webapp',
    properties: {
      context: {},
      properties: {
        properties: {
          content_type_id: {
            type: ['string', 'null'],
          },
          entity_type: {
            type: 'string',
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          result_count: {
            type: ['integer'],
          },
          search_filters: {
            items: {
              type: 'string',
            },
            type: 'array',
          },
          search_query: {
            type: ['string', 'null'],
          },
          sequence_key: {
            type: ['string', 'null'],
          },
          space_key: {
            type: ['string'],
          },
        },
        required: ['organization_key', 'space_key', 'entity_type', 'search_query', 'result_count'],
      },
      traits: {},
    },
    title: 'search_perform',
  };
  const message = {
    event: 'search_perform',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('search_perform', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'sharejs:cma_entity_version_mismatch' track call.
 *
 * @param {SharejsCmaEntityVersionMismatch} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function sharejsCmaEntityVersionMismatch(
  props?: SharejsCmaEntityVersionMismatch,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          payload: {
            properties: {
              cma_entity_version: {
                type: ['integer'],
              },
              entity_id: {
                type: ['string'],
              },
              entity_type: {
                type: ['string'],
              },
              share_js_doc_compressed_version: {
                type: ['integer'],
              },
              share_js_doc_version: {
                type: ['integer'],
              },
            },
            type: 'object',
          },
          scope: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'sharejs:cma_entity_version_mismatch',
    type: 'object',
  };
  const message = {
    event: 'sharejs:cma_entity_version_mismatch',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track(
      'sharejs:cma_entity_version_mismatch',
      props || {},
      withTypewriterContext(options),
      callback
    );
  }
}
/**
 * Schema to track slide in editor usage
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function slideInEditor(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema to track slide in editor usage',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            type: 'string',
          },
          current_slide_level: {
            type: ['integer'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: 'string',
          },
          peek_hover_time_ms: {
            type: ['integer'],
          },
          space_key: {
            type: 'string',
          },
          target_slide_level: {
            type: ['integer'],
          },
        },
        required: ['organization_key', 'space_key', 'current_slide_level'],
      },
      traits: {},
    },
    title: 'slide_in_editor',
  };
  const message = {
    event: 'slide_in_editor',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('slide_in_editor', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Legacy Snowplow schema (originally `space_create`) for tracking space creation. Heavily relies on Snowplow contexts. Numbers tracked went down to almost 0 since Nov 2020 presumably due to the new space creation flow which doesn't track space creation with this schema anymore.
 *
 * @param {SpaceCreate} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function spaceCreate(
  props?: SpaceCreate,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description:
      "Legacy Snowplow schema (originally `space_create`) for tracking space creation. Heavily relies on Snowplow contexts. Numbers tracked went down to almost 0 since Nov 2020 presumably due to the new space creation flow which doesn't track space creation with this schema anymore.",
    properties: {
      context: {},
      properties: {
        properties: {
          contexts: {
            type: 'string',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'space:create',
    type: 'object',
  };
  const message = {
    event: 'space:create',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('space:create', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'teams_in_space:users_added' track call.
 *
 * @param {TeamsInSpaceUsersAdded} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function teamsInSpaceUsersAdded(
  props?: TeamsInSpaceUsersAdded,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  num_err: {
                    type: ['integer'],
                  },
                  num_success: {
                    type: ['integer'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'teams_in_space:users_added',
    type: 'object',
  };
  const message = {
    event: 'teams_in_space:users_added',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('teams_in_space:users_added', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'text_editor:action' track call.
 *
 * @param {TextEditorAction} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function textEditorAction(
  props?: TextEditorAction,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              action_origin: {
                type: ['string'],
              },
              additional_data: {
                properties: {
                  character_count_after: {
                    type: ['integer'],
                  },
                  character_count_before: {
                    type: ['integer'],
                  },
                  character_count_selection: {
                    type: ['integer'],
                  },
                  link_type: {
                    type: ['string'],
                  },
                  mark_type: {
                    type: ['string'],
                  },
                  node_type: {
                    type: ['string'],
                  },
                },
                type: 'object',
              },
              character_count_after: {
                type: ['integer'],
              },
              character_count_before: {},
              character_count_selection: {},
              content_type_id: {
                type: ['string'],
              },
              editor_name: {
                type: ['string'],
              },
              entry_id: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              field_id: {
                type: ['string'],
              },
              field_locale: {
                type: ['string'],
              },
              is_fullscreen: {
                type: ['boolean'],
              },
              organization_key: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
          schema: {
            type: ['string'],
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'text_editor:action',
    type: 'object',
  };
  const message = {
    event: 'text_editor:action',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('text_editor:action', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'tracking:invalid_event' track call.
 *
 * @param {TrackingInvalidEvent} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function trackingInvalidEvent(
  props?: TrackingInvalidEvent,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            properties: {
              action: {
                type: ['string'],
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                type: ['string'],
              },
              payload: {
                properties: {
                  event: {
                    type: ['string'],
                  },
                },
                type: 'object',
              },
              scope: {
                type: ['string'],
              },
              space_key: {
                type: ['string'],
              },
            },
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {},
    },
    title: 'tracking:invalid_event',
    type: 'object',
  };
  const message = {
    event: 'tracking:invalid_event',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('tracking:invalid_event', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema to track the translation sidebar widgets
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function translationSidebar(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema to track the translation sidebar widgets',
    properties: {
      context: {},
      properties: {
        properties: {
          action: {
            description:
              '`toggle_widget_mode` is triggered every time the translation sidebar mode is toggled from single to multiple locales (or vice versa). `deselect_active_locale` is triggered when an editor is using the multiple locale mode and deselects one of the active locales using the pills in the sidebar widget. `update_active_locales` is triggered when an editor is using the multiple locale mode and updates the active locales using the locale update modal. `change_focused_locale` is triggered when an editor is using the single locale mode and changes the focused locale using the sidebar locale dropdown.',
            enum: [
              'toggle_widget_mode',
              'deselect_active_locale',
              'update_active_locales',
              'change_focused_locale',
            ],
            type: 'string',
          },
          current_active_locale_count: {
            description:
              'The total number of locales activated by the editor as a consequence of an `update_active_locales` or `deselect_active_locale` action.',
            type: ['integer', 'null'],
          },
          current_mode: {
            description:
              'The widget mode from which the action is executed. When the action is `toggle_widget_mode`, this refers to the mode to which the editor has toggled. Will always be `single` for `change_focused_locale`. Will always be `multiple` for `deselect_active_locale` or `update_active_locales`.',
            enum: ['single', 'multiple'],
            type: 'string',
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: 'string',
          },
          previous_active_locale_count: {
            description:
              'The total number of active locales prior to the triggering of an `update_active_locales` or `deselect_active_locale` action.',
            type: ['integer', 'null'],
          },
          space_key: {
            type: 'string',
          },
        },
        required: ['organization_key', 'space_key', 'action', 'current_mode'],
      },
      traits: {},
    },
    title: 'translation_sidebar',
  };
  const message = {
    event: 'translation_sidebar',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('translation_sidebar', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Track the view migration in `ui_config` endpoint per space
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function uiConfigMigrate(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Track the view migration in `ui_config` endpoint per space',
    properties: {
      context: {},
      properties: {
        properties: {
          endpoint: {
            type: ['string'],
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          view_count_migrated: {
            type: ['integer'],
          },
          view_count_migration_failed: {
            type: ['integer'],
          },
        },
        required: [
          'organization_key',
          'space_key',
          'view_count_migrated',
          'view_count_migration_failed',
          'endpoint',
        ],
      },
      traits: {},
    },
    title: 'ui_config_migrate',
  };
  const message = {
    event: 'ui_config_migrate',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('ui_config_migrate', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * UI Extension Install Schema
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function uiExtensionInstall(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'UI Extension Install Schema',
    properties: {
      context: {},
      properties: {
        properties: {
          environment_key: {
            type: ['string'],
          },
          field_types: {
            type: ['array', 'null'],
          },
          installation_params: {
            type: ['array', 'null'],
          },
          instance_params: {
            type: ['array', 'null'],
          },
          name: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          src: {
            type: ['string', 'null'],
          },
          type: {
            type: ['string', 'null'],
          },
          url: {
            type: ['string', 'null'],
          },
        },
        required: ['organization_key', 'space_key', 'name'],
      },
      traits: {},
    },
    title: 'ui_extension_install',
  };
  const message = {
    event: 'ui_extension_install',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('ui_extension_install', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * UI Extension Save Schema
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function uiExtensionSave(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'UI Extension Save Schema',
    properties: {
      context: {},
      properties: {
        properties: {
          fieldTypes: {
            type: ['string', 'null'],
          },
          installationParams: {
            type: ['string', 'null'],
          },
          instanceParams: {
            type: ['string', 'null'],
          },
          name: {
            type: ['string'],
          },
          src: {
            type: ['string', 'null'],
          },
          ui_extension_id: {
            type: 'string',
          },
          url: {
            type: ['string', 'null'],
          },
        },
        required: ['ui_extension_id', 'name', 'src'],
      },
      traits: {},
    },
    title: 'ui_extension_save',
  };
  const message = {
    event: 'ui_extension_save',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('ui_extension_save', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Saving webhook in the UI
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function uiWebhookEditorSave(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Saving webhook in the UI',
    properties: {
      context: {},
      properties: {
        properties: {
          body_transformation: {
            type: ['string', 'null'],
          },
          content_type_header: {
            type: ['string', 'null'],
          },
          custom_headers: {
            type: ['array', 'null'],
          },
          environment_key: {
            type: ['string'],
          },
          filters: {
            type: ['string', 'null'],
          },
          method: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          template_id: {
            type: ['string', 'null'],
          },
          topics: {
            type: ['array', 'null'],
          },
          url: {
            type: ['string'],
          },
          uses_http_basic: {
            type: ['boolean'],
          },
          version: {
            type: ['integer'],
          },
          webhook_id: {
            type: ['string'],
          },
          webhook_name: {
            type: ['string'],
          },
        },
        required: [
          'organization_key',
          'space_key',
          'webhook_id',
          'version',
          'webhook_name',
          'url',
          'uses_http_basic',
        ],
      },
      traits: {},
    },
    title: 'ui_webhook_editor_save',
  };
  const message = {
    event: 'ui_webhook_editor_save',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('ui_webhook_editor_save', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema of creating a view in the webapp
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function viewCreate(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema of creating a view in the webapp',
    properties: {
      context: {},
      properties: {
        properties: {
          content_type_id: {
            type: ['string', 'null'],
          },
          entity_type: {
            type: 'string',
          },
          environment_key: {
            type: ['string'],
          },
          folder_id: {
            type: ['string'],
          },
          folder_title: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          search_query: {
            type: ['string', 'null'],
          },
          space_key: {
            type: ['string'],
          },
          view_id: {
            type: ['string'],
          },
        },
        required: [
          'organization_key',
          'space_key',
          'entity_type',
          'search_query',
          'content_type_id',
          'folder_id',
          'folder_title',
          'view_id',
        ],
      },
      traits: {},
    },
    title: 'view_create',
  };
  const message = {
    event: 'view_create',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('view_create', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema of delete a view in the webapp
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function viewDelete(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema of delete a view in the webapp',
    properties: {
      context: {},
      properties: {
        properties: {
          entity_type: {
            type: 'string',
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          view_id: {
            type: ['string'],
          },
          view_type: {
            type: 'string',
          },
        },
        required: ['organization_key', 'space_key', 'entity_type', 'view_id', 'view_type'],
      },
      traits: {},
    },
    title: 'view_delete',
  };
  const message = {
    event: 'view_delete',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('view_delete', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema of editing a view in the webapp
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function viewEdit(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema of editing a view in the webapp',
    properties: {
      context: {},
      properties: {
        properties: {
          change_property: {
            type: ['string'],
          },
          entity_type: {
            type: 'string',
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          space_key: {
            type: ['string'],
          },
          view_id: {
            type: ['string'],
          },
          view_roles: {
            type: ['string', 'null'],
          },
          view_title: {
            type: ['string'],
          },
        },
        required: [
          'organization_key',
          'space_key',
          'entity_type',
          'view_id',
          'view_title',
          'view_roles',
          'change_property',
        ],
      },
      traits: {},
    },
    title: 'view_edit',
  };
  const message = {
    event: 'view_edit',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('view_edit', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Schema of loading a view in the webapp
 *
 * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function viewLoad(
  props?: Record<string, any>,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    description: 'Schema of loading a view in the webapp',
    properties: {
      context: {},
      properties: {
        properties: {
          content_type_id: {
            type: ['string', 'null'],
          },
          entity_type: {
            type: 'string',
          },
          environment_key: {
            type: ['string'],
          },
          organization_key: {
            type: ['string'],
          },
          search_query: {
            type: ['string', 'null'],
          },
          sequence_key: {
            type: ['string', 'null'],
          },
          space_key: {
            type: ['string'],
          },
          view_id: {
            type: ['string'],
          },
          view_roles: {
            type: ['string', 'null'],
          },
          view_title: {
            type: ['string'],
          },
          view_type: {
            type: 'string',
          },
        },
        required: [
          'organization_key',
          'space_key',
          'entity_type',
          'search_query',
          'content_type_id',
          'view_id',
          'view_type',
          'view_title',
          'view_roles',
        ],
      },
      traits: {},
    },
    title: 'view_load',
  };
  const message = {
    event: 'view_load',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track('view_load', props || {}, withTypewriterContext(options), callback);
  }
}
/**
 * Fires a 'widget_renderer:fallback_rendered' track call.
 *
 * @param {WidgetRendererFallbackRendered} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function widgetRendererFallbackRendered(
  props?: WidgetRendererFallbackRendered,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    labels: {},
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            description: '',
            properties: {
              app_definition_id: {
                description: '',
                type: 'string',
              },
              environment: {
                description: '',
                type: 'string',
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                description: '',
                type: 'string',
              },
              space_key: {
                description: '',
                type: 'string',
              },
              user_id: {
                description: '',
                type: 'string',
              },
            },
            required: [],
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {
        type: 'object',
      },
    },
    title: 'widget_renderer:fallback_rendered',
    type: 'object',
  };
  const message = {
    event: 'widget_renderer:fallback_rendered',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track(
      'widget_renderer:fallback_rendered',
      props || {},
      withTypewriterContext(options),
      callback
    );
  }
}
/**
 * Fires a 'widget_renderer:fallback_warning_shown' track call.
 *
 * @param {WidgetRendererFallbackWarningShown} [props] - The analytics properties that will be sent to Segment.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
 * 		call is fired.
 */
export function widgetRendererFallbackWarningShown(
  props?: WidgetRendererFallbackWarningShown,
  options?: Segment.Options,
  callback?: Segment.Callback
): void {
  const schema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    labels: {},
    properties: {
      context: {},
      properties: {
        properties: {
          data: {
            description: '',
            properties: {
              app_definition_id: {
                description: '',
                type: 'string',
              },
              environment: {
                description: '',
                type: 'string',
              },
              environment_key: {
                type: ['string'],
              },
              organization_key: {
                description: '',
                type: 'string',
              },
              space_key: {
                description: '',
                type: 'string',
              },
              user_id: {
                description: '',
                type: 'string',
              },
            },
            required: [],
            type: 'object',
          },
        },
        type: 'object',
      },
      traits: {
        type: 'object',
      },
    },
    title: 'widget_renderer:fallback_warning_shown',
    type: 'object',
  };
  const message = {
    event: 'widget_renderer:fallback_warning_shown',
    properties: props || {},
    options,
  };
  validateAgainstSchema(message, schema);

  const a = analytics();
  if (a) {
    a.track(
      'widget_renderer:fallback_warning_shown',
      props || {},
      withTypewriterContext(options),
      callback
    );
  }
}

const clientAPI = {
  /**
   * Updates the run-time configuration of this Typewriter client.
   *
   * @param {TypewriterOptions} options - the options to upsert
   *
   * @typedef {Object} TypewriterOptions
   * @property {Segment.AnalyticsJS} [analytics] - Underlying analytics instance where analytics
   * 		calls are forwarded on to. Defaults to window.analytics.
   * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
   * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
   * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
   * 		will be logged to stderr.
   */
  setTypewriterOptions,
  /**
   * Fires a 'account_dropdown:pending_tasks_fetched' track call.
   *
   * @param {AccountDropdownPendingTasksFetched} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  accountDropdownPendingTasksFetched,
  /**
   * ApiKey schema
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  apiKey,
  /**
   * Records an app definition lifecycle event
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  appDefinition,
  /**
   * Records an app installation lifecycle event
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  appInstallation,
  /**
   * Records an event in App lifecycle
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  appLifecycleEvent,
  /**
   * Fires a 'app_management:created' track call.
   *
   * @param {AppManagementCreated} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  appManagementCreated,
  /**
   * Fires a 'app_management:updated' track call.
   *
   * @param {AppManagementUpdated} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  appManagementUpdated,
  /**
   * Web app opened by visiting app.contentful.com
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  appOpen,
  /**
   * Event fired when the example app opens
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  appTheExampleAppOpen,
  /**
   * Records a reason for App uninstallation
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  appUninstallationReason,
  /**
   * Fires a 'apps:lifecycle_event' track call.
   *
   * @param {AppsLifecycleEvent} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  appsLifecycleEvent,
  /**
   * Fires a 'asset_created' track call.
   *
   * @param {AssetCreated} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  assetCreated,
  /**
   * Fires a 'asset_list:add_asset_multiple' track call.
   *
   * @param {AssetListAddAssetMultiple} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  assetListAddAssetMultiple,
  /**
   * Fires a 'asset_list:add_asset_single' track call.
   *
   * @param {AssetListAddAssetSingle} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  assetListAddAssetSingle,
  /**
   * Fires a 'asset_published' track call.
   *
   * @param {AssetPublished} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  assetPublished,
  /**
   * Tracks usage of boilerplate projects
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  boilerplate,
  /**
   * Fires a 'bulk_editor:close' track call.
   *
   * @param {BulkEditorClose} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  bulkEditorClose,
  /**
   * Fires a 'bulk_editor:edit_in_entry_editor' track call.
   *
   * @param {BulkEditorEditInEntryEditor} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  bulkEditorEditInEntryEditor,
  /**
   * Fires a 'bulk_editor:open' track call.
   *
   * @param {BulkEditorOpen} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  bulkEditorOpen,
  /**
   * Fires a 'bulk_editor:open_slide_in' track call.
   *
   * @param {BulkEditorOpenSlideIn} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  bulkEditorOpenSlideIn,
  /**
   * Schema for any event that has to do with content preview in our webapp
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  contentPreview,
  /**
   * ContentTyppe schema
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  contentType,
  /**
   * Emitted when a job is triggered
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  dialog,
  /**
   * Fires a 'editor_interface_field_updated' track call.
   *
   * @param {EditorInterfaceFieldUpdated} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  editorInterfaceFieldUpdated,
  /**
   * Fires a 'editor_loaded' track call.
   *
   * @param {EditorLoaded} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  editorLoaded,
  /**
   * Fires a 'editor_workbench:tab_open' track call.
   *
   * @param {EditorWorkbenchTabOpen} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  editorWorkbenchTabOpen,
  /**
   * Fires a 'element:click' track call.
   *
   * @param {ElementClick} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  elementClick,
  /**
   * ShareJS removal, CMA-only entity editor edit conflicts tracking. This event is tracked when persisting local editor changes fails due to a CMA version mismatch error. `local_entity` refers to the last CMA version of the entity known to the entity editor without local changes and before the conflict. All pending local changes are based on this entity version. `remote_entity` refers to the most recent version of the entity which has caused the version mismatch and thus might have conflicts with the local changes on top of `local_entity`.
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  entityEditorEditConflict,
  /**
   * EXPERIMENT for Snowplow -> Segment migration (hence "_2" suffix) | ShareJS removal, CMA-only entity editor edit conflicts tracking. This event is tracked when persisting local editor changes fails due to a CMA version mismatch error. `local_entity` refers to the last CMA version of the entity known to the entity editor without local changes and before the conflict. All pending local changes are based on this entity version. `remote_entity` refers to the most recent version of the entity which has caused the version mismatch and thus might have conflicts with the local changes on top of `local_entity`.
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  entityEditorEditConflict2,
  /**
   * Entry schema
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  entry,
  /**
   * Fires a 'entry:publish' track call.
   *
   * @param {EntryPublish} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  entryPublish,
  /**
   * Schema of creating an entry in the webapp
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  entryCreate,
  /**
   * Fires a 'entry_created' track call.
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  entryCreated,
  /**
   * Schema of publishing an entry in the webapp
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  entryPublish1,
  /**
   * Schema of entry references
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  entryReferences,
  /**
   * Fires a 'entry_references:dialog_open' track call.
   *
   * @param {EntryReferencesDialogOpen} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  entryReferencesDialogOpen,
  /**
   * Fires a 'entry_references:publish' track call.
   *
   * @param {EntryReferencesPublish} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  entryReferencesPublish,
  /**
   * Fires a 'entry_references:validate' track call.
   *
   * @param {EntryReferencesValidate} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  entryReferencesValidate,
  /**
   * Schema for tracking entry page views
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  entryView,
  /**
   * Environment aliases tracking
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  environmentAliases,
  /**
   * Environment branching tracking
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  environmentBranching,
  /**
   * Schema for A/B tests, inside of the user_interface
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  experiment,
  /**
   * Allows to track which user is part of a UI experiment or a particular A/B test variation, e.g. controlled through `LaunchDarkly` or another kind of feature flag.
   *
   * @param {ExperimentStarted} props - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  experimentStarted,
  /**
   * Extension was activated
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  extensionActivate,
  /**
   * Extension rendered
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  extensionRender,
  /**
   * Extension set a value of a field
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  extensionSetValue,
  /**
   * Bulk references editor feature tracking
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  featureBulkEditor,
  /**
   * Events for the comments endpoint, emitted on CUD actions. Note: The Tasks feature is using the comments endpoint behind the scenes.
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  featureCommentsAndTasks,
  /**
   * Generated empty schema for feature_playground
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  featurePlayground,
  /**
   * Schema of interacting with a reference entry
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  featureReferenceAction,
  /**
   * Snapshot tracking feature
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  featureSnapshot,
  /**
   * Action tracking for Single Sign-On (SSO) Self Configuration via the webapp
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  featureSsoSelfConfiguration,
  /**
   * Generic event for tracking text editor widgets (e.g. StructuredText or Markdown).
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  featureTextEditor,
  /**
   * Fires a 'global:app_loaded' track call.
   *
   * @param {GlobalAppLoaded} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  globalAppLoaded,
  /**
   * Fires a 'global:dialog' track call.
   *
   * @param {GlobalDialog} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  globalDialog,
  /**
   * Fires a 'global:space_changed' track call.
   *
   * @param {GlobalSpaceChanged} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  globalSpaceChanged,
  /**
   * Fires a 'global:space_left' track call.
   *
   * @param {GlobalSpaceLeft} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  globalSpaceLeft,
  /**
   * Fires a 'global:state_changed' track call.
   *
   * @param {GlobalStateChanged} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  globalStateChanged,
  /**
   * Fires a 'incoming_links:dialog_confirm' track call.
   *
   * @param {IncomingLinksDialogConfirm} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  incomingLinksDialogConfirm,
  /**
   * Fires a 'incoming_links:dialog_open' track call.
   *
   * @param {IncomingLinksDialogOpen} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  incomingLinksDialogOpen,
  /**
   * Fires a 'incoming_links:query' track call.
   *
   * @param {IncomingLinksQuery} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  incomingLinksQuery,
  /**
   * Emitted when the user cancels the job
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  jobsCancel,
  /**
   * Emitted when a user creates a job
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  jobsCreate,
  /**
   * Emitted when a job is triggered
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  jobsProcessing,
  /**
   * Schema for tracking every state transition in the user interface
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  pageView,
  /**
   * Fires a 'perf:dom_content_loaded' track call.
   *
   * @param {PerfDomContentLoaded} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  perfDomContentLoaded,
  /**
   * Fires a 'perf:first_contentful_paint' track call.
   *
   * @param {PerfFirstContentfulPaint} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  perfFirstContentfulPaint,
  /**
   * Fires a 'perf:time_to_interactive' track call.
   *
   * @param {PerfTimeToInteractive} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  perfTimeToInteractive,
  /**
   * Fires a 'personal_access_token:action' track call.
   *
   * @param {PersonalAccessTokenAction} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  personalAccessTokenAction,
  /**
   * PrevieApiKey schema
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  previewApiKey,
  /**
   * Fires a 'release_created' track call.
   *
   * @param {ReleaseCreated} props - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  releaseCreated,
  /**
   * Fires a 'release_dialog_box' track call.
   *
   * @param {ReleaseDialogBox} props - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  releaseDialogBox,
  /**
   * Fires a 'release_entity_added' track call.
   *
   * @param {ReleaseEntityAdded} props - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  releaseEntityAdded,
  /**
   * Fires a 'release_entity_removed' track call.
   *
   * @param {ReleaseEntityRemoved} props - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  releaseEntityRemoved,
  /**
   * Fires a 'release_published' track call.
   *
   * @param {ReleasePublished} props - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  releasePublished,
  /**
   * Fires a 'release_schedule_canceled' track call.
   *
   * @param {ReleaseScheduleCanceled} props - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  releaseScheduleCanceled,
  /**
   * Fires a 'release_schedule_created' track call.
   *
   * @param {ReleaseScheduleCreated} props - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  releaseScheduleCreated,
  /**
   * Fires a 'release_trashed' track call.
   *
   * @param {ReleaseTrashed} props - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  releaseTrashed,
  /**
   * Fires a 'search:entry_clicked' track call.
   *
   * @param {SearchEntryClicked} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  searchEntryClicked,
  /**
   * Fires a 'search:filter_added' track call.
   *
   * @param {SearchFilterAdded} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  searchFilterAdded,
  /**
   * Fires a 'search:filter_removed' track call.
   *
   * @param {SearchFilterRemoved} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  searchFilterRemoved,
  /**
   * Fires a 'search:query_changed' track call.
   *
   * @param {SearchQueryChanged} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  searchQueryChanged,
  /**
   * Fires a 'search:search_performed' track call.
   *
   * @param {SearchSearchPerformed} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  searchSearchPerformed,
  /**
   * Fires a 'search:view_created' track call.
   *
   * @param {SearchViewCreated} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  searchViewCreated,
  /**
   * Fires a 'search:view_deleted' track call.
   *
   * @param {SearchViewDeleted} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  searchViewDeleted,
  /**
   * Fires a 'search:view_loaded' track call.
   *
   * @param {SearchViewLoaded} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  searchViewLoaded,
  /**
   * Schema for a search performed in the top bar of the webapp
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  searchPerform,
  /**
   * Fires a 'sharejs:cma_entity_version_mismatch' track call.
   *
   * @param {SharejsCmaEntityVersionMismatch} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  sharejsCmaEntityVersionMismatch,
  /**
   * Schema to track slide in editor usage
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  slideInEditor,
  /**
   * Legacy Snowplow schema (originally `space_create`) for tracking space creation. Heavily relies on Snowplow contexts. Numbers tracked went down to almost 0 since Nov 2020 presumably due to the new space creation flow which doesn't track space creation with this schema anymore.
   *
   * @param {SpaceCreate} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  spaceCreate,
  /**
   * Fires a 'teams_in_space:users_added' track call.
   *
   * @param {TeamsInSpaceUsersAdded} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  teamsInSpaceUsersAdded,
  /**
   * Fires a 'text_editor:action' track call.
   *
   * @param {TextEditorAction} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  textEditorAction,
  /**
   * Fires a 'tracking:invalid_event' track call.
   *
   * @param {TrackingInvalidEvent} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  trackingInvalidEvent,
  /**
   * Schema to track the translation sidebar widgets
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  translationSidebar,
  /**
   * Track the view migration in `ui_config` endpoint per space
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  uiConfigMigrate,
  /**
   * UI Extension Install Schema
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  uiExtensionInstall,
  /**
   * UI Extension Save Schema
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  uiExtensionSave,
  /**
   * Saving webhook in the UI
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  uiWebhookEditorSave,
  /**
   * Schema of creating a view in the webapp
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  viewCreate,
  /**
   * Schema of delete a view in the webapp
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  viewDelete,
  /**
   * Schema of editing a view in the webapp
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  viewEdit,
  /**
   * Schema of loading a view in the webapp
   *
   * @param {Record<string, any>} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  viewLoad,
  /**
   * Fires a 'widget_renderer:fallback_rendered' track call.
   *
   * @param {WidgetRendererFallbackRendered} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  widgetRendererFallbackRendered,
  /**
   * Fires a 'widget_renderer:fallback_warning_shown' track call.
   *
   * @param {WidgetRendererFallbackWarningShown} [props] - The analytics properties that will be sent to Segment.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics
   * 		call is fired.
   */
  widgetRendererFallbackWarningShown,
};

export default new Proxy<typeof clientAPI>(clientAPI, {
  get(target, method) {
    if (typeof method === 'string' && target.hasOwnProperty(method)) {
      return target[method as keyof typeof clientAPI];
    }

    return () => {
      console.warn(`  You made an analytics call (${String(method)}) that can't be found. Either:
    a) Re-generate your typewriter client: \`npx typewriter\`
    b) Add it to your Tracking Plan: https://app.segment.com/contentful-staging/protocols/tracking-plans/rs_1YwenhuqVMybvb7zC1c0OEAP6Cj`);
      const a = analytics();
      if (a) {
        a.track(
          'Unknown Analytics Call Fired',
          {
            method,
          },
          withTypewriterContext()
        );
      }
    };
  },
});
