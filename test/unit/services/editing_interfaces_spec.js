'use strict';

describe('Editing interfaces service', function () {
  var widgets, editingInterfaces, cfStub;

  beforeEach(function () {
    module('contentful/test');

    widgets           = this.$inject('widgets');
    editingInterfaces = this.$inject('editingInterfaces');
    cfStub            = this.$inject('cfStub');
  });

  describe('#forContentType()', function() {
    beforeEach(function () {
      this.contentType = {
        getEditingInterface: sinon.stub(),
        newEditingInterface: sinon.spy(function (data) {
          return {data: data};
        }),
        getId: sinon.stub(),
        data: {
          sys: {revision: 1},
          fields: [ {id: 'id1',  apiName: 'apiName1'}]
        }
      };

      this.getEditingInterface = function () {
        var editingInterface;
        editingInterfaces.forContentType(this.contentType)
        .then(function (ei) {
          editingInterface = ei;
        });
        this.$apply();
        return editingInterface;
      };
    });

    describe('with API data', function() {
      beforeEach(function() {
        this.contentType.getEditingInterface.resolves({
          data: {widgets: [{
            fieldId: 'apiName1',
            widgetParams: {},
          }]}
        });
      });

      it('requests the default id', function() {
        this.getEditingInterface();
        sinon.assert.calledWith(this.contentType.getEditingInterface, 'default');
      });

      it('returns editing interface with widgets', function() {
        var widgets = this.getEditingInterface().data.widgets;
        expect(widgets.length).toEqual(1);
      });

      it('adds widget if field widget is missing', function(){
        this.contentType.data.fields.push({
          id: 'id2',
          apiName: 'apiName2',
        });
        var widgets = this.getEditingInterface().data.widgets;

        expect(widgets[0].fieldId).toBe('apiName1');
        expect(widgets[1].fieldId).toBe('apiName2');
      });

      it('sets default widget parameters', function(){
        var widgets = this.$inject('widgets');
        sinon.stub(widgets, 'paramDefaults').returns({foo: 'bar'});
        var widgetArr = this.getEditingInterface().data.widgets;
        sinon.assert.called(widgets.paramDefaults);
        expect(widgetArr[0].widgetParams).toEqual({foo: 'bar'});
      });
    });

    describe('if content type is new', function () {
      beforeEach(function () {
        this.contentType.data.fields = [];
        delete this.contentType.data.sys.revision;
        this.contentType.newEditingInterface = sinon.spy(function (data) {
          return {data: data};
        });
      });

      it('does not call "getEditingInterface"', function () {
        this.getEditingInterface();
        sinon.assert.notCalled(this.contentType.getEditingInterface);
      });

      it('call "newEditingInterface"', function () {
        this.getEditingInterface();
        sinon.assert.called(this.contentType.newEditingInterface);
      });

      it('returns interface with empty widgets', function () {
        var editingInterface = this.getEditingInterface();
        expect(editingInterface.data.widgets).toEqual([]);
      });
    });

    it('gets a default config if interface does not exit', function() {
      this.contentType.getEditingInterface.rejects({statusCode: 404});
      var editingInterface = this.getEditingInterface();
      expect(editingInterface.data.widgets.length).toBe(1);
    });

    it('fails if API returns error', function() {
      var apiError = {};
      this.contentType.getEditingInterface.rejects(apiError);

      var errorHandler = sinon.stub();
      editingInterfaces.forContentType(this.contentType)
      .catch(errorHandler);

      this.$apply();
      sinon.assert.calledWithExactly(errorHandler, apiError);
    });

  });

  describe('#syncWidgets()', function() {
    beforeEach(function(){
      this.editingInterface = {data: {widgets: [
        {fieldId: 'apiName1'},
        {fieldId: 'apiName2'}
      ]}};
      this.contentType = {
        data: {fields: [
          {id: 'id1', apiName: 'apiName1'},
          {id: 'id2', apiName: 'apiName2'},
        ]},
        getId: sinon.stub().returns('fieldid')
      };
    });

    it('add widgets for missing fields', function() {
      this.contentType.data.fields.push({
        id: 'id3',
        apiName: 'apiName3',
      });
      editingInterfaces.syncWidgets(this.contentType, this.editingInterface);
      var expectedWidgets = [
        {fieldId: 'apiName1'},
        {fieldId: 'apiName2'},
        // The newly created widget
        {fieldId: 'apiName3', widgetId: undefined, widgetParams: {}}
      ];
      // Autogenerated id we can't match
      delete this.editingInterface.data.widgets[2].id;
      expect(this.editingInterface.data.widgets).toEqual(expectedWidgets);
    });

    it('removes widgets without fields', function() {
      this.editingInterface.data.widgets.push({id: 'noMatch'});
      editingInterfaces.syncWidgets(this.contentType, this.editingInterface);
      var expectedWidgets = [
        {fieldId: 'apiName1'},
        {fieldId: 'apiName2'}
      ];
      expect(this.editingInterface.data.widgets).toEqual(expectedWidgets);
    });
  });

  // These tests cover the migration of editing interface from internal IDs to external
  // apiNames. If the apiNames do not exist (for example old editor interfaces) we should
  // fall back on the id.
  // See https://contentful.atlassian.net/wiki/x/HwEJAg and
  // https://contentful.tpondemand.com/entity/7098
  describe('Editing interface migration tests', function() {
    // Should retrieve the content types' editor interface with `fieldId` mapped to apiNames.
    // It should *not* drop the widget and create a new one.
    describe('#forContentType()', function() {
      function makeContentType(fields, editingInterface) {
        return {
          data: {
            sys: {revision: 1},
            fields: fields
          },
          getEditingInterface: sinon.stub().resolves(editingInterface),
          getId: sinon.stub(),
        };
      }

      pit('maps ids to apiNames for a non-migrated editing interface returned from API', function(){
        var contentTypeFields = [
          { id: 'id1', apiName: 'apiName1'},
          { id: 'id2', apiName: 'apiName2'}
        ];

        var editingInterfaceWidgets = [
          { id: 'id1', fieldId: 'id1' },
          { id: 'id2', fieldId: 'id2' }
        ];
        var expectedWidgets = [
          { id: 'id1', fieldId: 'apiName1' },
          { id: 'id2', fieldId: 'apiName2' }
        ];

        var editingInterface = {data: { widgets: editingInterfaceWidgets }};
        var contentType = makeContentType(contentTypeFields, editingInterface);
        return editingInterfaces.forContentType(contentType).then(function(editingInterface) {
          expect(editingInterface.data.widgets).toEqual(expectedWidgets);
        });
      });

      pit('falls back on id for a content type field that does not have an apiName', function() {
        var contentTypeFields = [{ id: 'id1'}];

        var editingInterfaceWidgets = [{ id: 'widget1', fieldId: 'id1' }];
        var expectedWidgets = _.cloneDeep(editingInterfaceWidgets);

        var editingInterface = {data: { widgets: editingInterfaceWidgets }};
        var contentType = makeContentType(contentTypeFields, editingInterface);

        return editingInterfaces.forContentType(contentType).then(function(editingInterface) {
          expect(editingInterface.data.widgets).toEqual(expectedWidgets);
        });
      });

      pit('does not manipulate a widget with an already remapped id to apiName', function(){
        var contentTypeFields = [{ id: 'id1', apiName: 'apiName1'}];

        var editingInterfaceWidgets = [{ id: 'widget1', fieldId: 'apiName1' }];
        var expectedWidgets = [{id: 'widget1', fieldId: 'apiName1'}];

        var editingInterface = {data: { widgets: editingInterfaceWidgets }};
        var contentType = makeContentType(contentTypeFields, editingInterface);

        return editingInterfaces.forContentType(contentType).then(function(editingInterface) {
          expect(editingInterface.data.widgets).toEqual(expectedWidgets);
        });
      });

      // Tests that the default widget uses a fields apiName and falls back to id
      describe('default interface', function() {
        function makeContentType(fields) {
          return {
            data: {fields: fields},
            newEditingInterface: function (data) {
              return {data: data};
            },
            getEditingInterface: sinon.stub().rejects({statusCode: 404}),
            getId: sinon.stub(),
            getVersion: sinon.stub()
          };
        }

        pit('creates a default interface and maps `fieldId` to apiName', function(){
          var contentType = makeContentType([{ id: 'id1', apiName: 'apiName1' }]);
          var expectedWidgets = [
            {fieldId: 'apiName1', widgetId: undefined, widgetParams: {}}
          ];

          return editingInterfaces.forContentType(contentType)
          .then(function (resultingEI) {
            // Autogenerated id we can't match
            delete resultingEI.data.widgets[0].id;

            expect(resultingEI.data.widgets).toEqual(expectedWidgets);
          });
        });

        it('falls back to `id` when `apiName` doesnt exist in a field', function() {
          var contentType = makeContentType([{ id: 'id1' }]);

          var expectedWidgets = [
            {fieldId: 'id1', widgetId: undefined, widgetParams: {}}
          ];

          return editingInterfaces.forContentType(contentType)
          .then(function (resultingEI) {
            // Autogenerated id we can't match
            delete resultingEI.data.widgets[0].id;

            expect(resultingEI.data.widgets).toEqual(expectedWidgets);
          });
        });
      });
    });

    describe('#syncWidgets()', function() {
      it('maps ids to apiName for non-migrated editing interfaces', function(){
        var contentTypeFields = [{ id: 'id1', apiName: 'apiName1'}];

        var editingInterfaceWidgets = [{ id: 'widget1', fieldId: 'id1'}];
        var expectedWidgets = [{ id: 'widget1', fieldId: 'apiName1'}];

        var contentType = {data: {fields: contentTypeFields}};
        var editingInterface = {data: {widgets: editingInterfaceWidgets}};

        var resultingEI = editingInterfaces.syncWidgets(contentType, editingInterface);
        expect(resultingEI.data.widgets).toEqual(expectedWidgets);
      });

      it('falls back on id for a content type field that does not have an apiName', function() {
        var contentTypeFields = [{ id: 'id1'}];

        var editingInterfaceWidgets = [{ id: 'widget1', fieldId: 'id1'}];
        var expectedWidgets = _.cloneDeep(editingInterfaceWidgets);

        var contentType = {data: {fields: contentTypeFields}};
        var editingInterface = {data: {widgets: editingInterfaceWidgets}};

        var resultingEI = editingInterfaces.syncWidgets(contentType, editingInterface);
        expect(resultingEI.data.widgets).toEqual(expectedWidgets);
      });

      it('does not re-create or prune a widget with an already remapped apiName', function () {
        var contentTypeFields = [{ id: 'id1', apiName: 'apiName1'}];

        var editingInterfaceWidgets = [{ id: 'widget1', fieldId: 'apiName1'}];
        var expectedWidgets = [{ id: 'widget1', fieldId: 'apiName1'}];

        var contentType = {data: {fields: contentTypeFields}};
        var editingInterface = {data: {widgets: editingInterfaceWidgets}};

        var resultingEI = editingInterfaces.syncWidgets(contentType, editingInterface);
        expect(resultingEI.data.widgets).toEqual(expectedWidgets);
      });
    });

  });
});

